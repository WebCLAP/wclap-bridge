/* Generated by translate-clap-api.js */

template<>
struct Wclap::TranslateStruct<clap_host_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_t &native) {
		translate->assignWasmToNativeDirect<clap_version_t>(wasmP, native.clap_version);
		translate->assignWasmToNative_clap_host_t_host_data(wasmP + 12, native.host_data);
		translate->assignWasmToNative<const char *>(wasmP + 16, native.name);
		translate->assignWasmToNative<const char *>(wasmP + 16, native.vendor);
		translate->assignWasmToNative<const char *>(wasmP + 16, native.url);
		translate->assignWasmToNative<const char *>(wasmP + 16, native.version);
		translate->assignWasmToNative_clap_host_t_get_extension(wasmP + 16, native.get_extension);
		translate->assignWasmToNative_vi(wasmP + 20, native.request_restart); // void request_restart()
		translate->assignWasmToNative_vi(wasmP + 24, native.request_process); // void request_process()
		translate->assignWasmToNative_vi(wasmP + 28, native.request_callback); // void request_callback()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<clap_version_t>(native.clap_version, wasmP);
		translate->assignNativeToWasm_clap_host_t_host_data(native.host_data, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.name, wasmP + 16);
		translate->assignNativeToWasm<uint32_t>(native.vendor, wasmP + 16);
		translate->assignNativeToWasm<uint32_t>(native.url, wasmP + 16);
		translate->assignNativeToWasm<uint32_t>(native.version, wasmP + 16);
		translate->assignNativeToWasm_clap_host_t_get_extension(native.get_extension, wasmP + 16);
		translate->assignNativeToWasm_vi(native.request_restart, wasmP + 20); // void request_restart(clap_host_t *)
		translate->assignNativeToWasm_vi(native.request_process, wasmP + 24); // void request_process(clap_host_t *)
		translate->assignNativeToWasm_vi(native.request_callback, wasmP + 28); // void request_callback(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_istream_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_istream_t &native) {
		translate->assignWasmToNative_clap_istream_t_ctx(wasmP, native.ctx);
		translate->assignWasmToNative_clap_istream_t_read(wasmP + 4, native.read);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_istream_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_istream_t_ctx(native.ctx, wasmP);
		translate->assignNativeToWasm_clap_istream_t_read(native.read, wasmP + 4);
	}
};
template<>
struct Wclap::TranslateStruct<clap_ostream_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_ostream_t &native) {
		translate->assignWasmToNative_clap_ostream_t_ctx(wasmP, native.ctx);
		translate->assignWasmToNative_clap_ostream_t_write(wasmP + 4, native.write);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_ostream_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_ostream_t_ctx(native.ctx, wasmP);
		translate->assignNativeToWasm_clap_ostream_t_write(native.write, wasmP + 4);
	}
};
template<>
struct Wclap::TranslateStruct<clap_audio_buffer_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_audio_buffer_t &native) {
		translate->assignWasmToNative_clap_audio_buffer_t_data32(wasmP, native.data32);
		translate->assignWasmToNative_clap_audio_buffer_t_data64(wasmP + 4, native.data64);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 8, native.channel_count);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 12, native.latency);
		translate->assignWasmToNativeDirect<uint64_t>(wasmP + 16, native.constant_mask);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_audio_buffer_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_audio_buffer_t_data32(native.data32, wasmP);
		translate->assignNativeToWasm_clap_audio_buffer_t_data64(native.data64, wasmP + 4);
		translate->assignNativeToWasmDirect<uint32_t>(native.channel_count, wasmP + 8);
		translate->assignNativeToWasmDirect<uint32_t>(native.latency, wasmP + 12);
		translate->assignNativeToWasmDirect<uint64_t>(native.constant_mask, wasmP + 16);
	}
};
template<>
struct Wclap::TranslateStruct<clap_event_param_value_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_event_param_value_t &native) {
		translate->assignWasmToNativeDirect<clap_event_header_t>(wasmP, native.header);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 16, native.param_id);
		translate->assignWasmToNative_clap_event_param_value_t_cookie(wasmP + 20, native.cookie);
		translate->assignWasmToNativeDirect<int32_t>(wasmP + 24, native.note_id);
		translate->assignWasmToNativeDirect<int16_t>(wasmP + 28, native.port_index);
		translate->assignWasmToNativeDirect<int16_t>(wasmP + 30, native.channel);
		translate->assignWasmToNativeDirect<int16_t>(wasmP + 32, native.key);
		translate->assignWasmToNativeDirect<double>(wasmP + 40, native.value);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_event_param_value_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<clap_event_header_t>(native.header, wasmP);
		translate->assignNativeToWasmDirect<uint32_t>(native.param_id, wasmP + 16);
		translate->assignNativeToWasm_clap_event_param_value_t_cookie(native.cookie, wasmP + 20);
		translate->assignNativeToWasmDirect<int32_t>(native.note_id, wasmP + 24);
		translate->assignNativeToWasmDirect<int16_t>(native.port_index, wasmP + 28);
		translate->assignNativeToWasmDirect<int16_t>(native.channel, wasmP + 30);
		translate->assignNativeToWasmDirect<int16_t>(native.key, wasmP + 32);
		translate->assignNativeToWasmDirect<double>(native.value, wasmP + 40);
	}
};
template<>
struct Wclap::TranslateStruct<clap_event_param_mod_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_event_param_mod_t &native) {
		translate->assignWasmToNativeDirect<clap_event_header_t>(wasmP, native.header);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 16, native.param_id);
		translate->assignWasmToNative_clap_event_param_mod_t_cookie(wasmP + 20, native.cookie);
		translate->assignWasmToNativeDirect<int32_t>(wasmP + 24, native.note_id);
		translate->assignWasmToNativeDirect<int16_t>(wasmP + 28, native.port_index);
		translate->assignWasmToNativeDirect<int16_t>(wasmP + 30, native.channel);
		translate->assignWasmToNativeDirect<int16_t>(wasmP + 32, native.key);
		translate->assignWasmToNativeDirect<double>(wasmP + 40, native.amount);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_event_param_mod_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<clap_event_header_t>(native.header, wasmP);
		translate->assignNativeToWasmDirect<uint32_t>(native.param_id, wasmP + 16);
		translate->assignNativeToWasm_clap_event_param_mod_t_cookie(native.cookie, wasmP + 20);
		translate->assignNativeToWasmDirect<int32_t>(native.note_id, wasmP + 24);
		translate->assignNativeToWasmDirect<int16_t>(native.port_index, wasmP + 28);
		translate->assignNativeToWasmDirect<int16_t>(native.channel, wasmP + 30);
		translate->assignNativeToWasmDirect<int16_t>(native.key, wasmP + 32);
		translate->assignNativeToWasmDirect<double>(native.amount, wasmP + 40);
	}
};
template<>
struct Wclap::TranslateStruct<clap_event_midi_sysex_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_event_midi_sysex_t &native) {
		translate->assignWasmToNativeDirect<clap_event_header_t>(wasmP, native.header);
		translate->assignWasmToNativeDirect<uint16_t>(wasmP + 16, native.port_index);
		translate->assignWasmToNative_clap_event_midi_sysex_t_buffer(wasmP + 20, native.buffer);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 24, native.size);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_event_midi_sysex_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<clap_event_header_t>(native.header, wasmP);
		translate->assignNativeToWasmDirect<uint16_t>(native.port_index, wasmP + 16);
		translate->assignNativeToWasm_clap_event_midi_sysex_t_buffer(native.buffer, wasmP + 20);
		translate->assignNativeToWasmDirect<uint32_t>(native.size, wasmP + 24);
	}
};
template<>
struct Wclap::TranslateStruct<clap_input_events_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_input_events_t &native) {
		translate->assignWasmToNative_clap_input_events_t_ctx(wasmP, native.ctx);
		translate->assignWasmToNative_ii(wasmP + 4, native.size); // uint32_t size()
		translate->assignWasmToNative_iii(wasmP + 8, native.get); // clap_event_header_t * get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_input_events_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_input_events_t_ctx(native.ctx, wasmP);
		translate->assignNativeToWasm_ii(native.size, wasmP + 4); // uint32_t size(clap_input_events_t *)
		translate->assignNativeToWasm_iii(native.get, wasmP + 8); // clap_event_header_t * get(clap_input_events_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_output_events_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_output_events_t &native) {
		translate->assignWasmToNative_clap_output_events_t_ctx(wasmP, native.ctx);
		translate->assignWasmToNative_iii(wasmP + 4, native.try_push); // bool try_push()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_output_events_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_output_events_t_ctx(native.ctx, wasmP);
		translate->assignNativeToWasm_iii(native.try_push, wasmP + 4); // bool try_push(clap_output_events_t *,clap_event_header_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_process_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_process_t &native) {
		translate->assignWasmToNativeDirect<int64_t>(wasmP, native.steady_time);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 8, native.frames_count);
		translate->assignWasmToNativeDirectPointer<clap_event_transport_t *>(wasmP + 12, native.transport);
		translate->assignWasmToNative<clap_audio_buffer_t *>(wasmP + 16, native.audio_inputs);
		translate->assignWasmToNative<clap_audio_buffer_t *>(wasmP + 20, native.audio_outputs);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 24, native.audio_inputs_count);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 28, native.audio_outputs_count);
		translate->assignWasmToNative<clap_input_events_t *>(wasmP + 32, native.in_events);
		translate->assignWasmToNative<clap_output_events_t *>(wasmP + 36, native.out_events);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_process_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<int64_t>(native.steady_time, wasmP);
		translate->assignNativeToWasmDirect<uint32_t>(native.frames_count, wasmP + 8);
		translate->assignNativeToWasmDirectPointer<clap_event_transport_t *>(native.transport, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.audio_inputs, wasmP + 16);
		translate->assignNativeToWasm<uint32_t>(native.audio_outputs, wasmP + 20);
		translate->assignNativeToWasmDirect<uint32_t>(native.audio_inputs_count, wasmP + 24);
		translate->assignNativeToWasmDirect<uint32_t>(native.audio_outputs_count, wasmP + 28);
		translate->assignNativeToWasm<uint32_t>(native.in_events, wasmP + 32);
		translate->assignNativeToWasm<uint32_t>(native.out_events, wasmP + 36);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_descriptor_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_descriptor_t &native) {
		translate->assignWasmToNativeDirect<clap_version_t>(wasmP, native.clap_version);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.id);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.name);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.vendor);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.url);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.manual_url);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.support_url);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.version);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.description);
		translate->assignWasmToNative_clap_plugin_descriptor_t_features(wasmP + 12, native.features);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_descriptor_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<clap_version_t>(native.clap_version, wasmP);
		translate->assignNativeToWasm<uint32_t>(native.id, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.name, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.vendor, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.url, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.manual_url, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.support_url, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.version, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.description, wasmP + 12);
		translate->assignNativeToWasm_clap_plugin_descriptor_t_features(native.features, wasmP + 12);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_t &native) {
		translate->assignWasmToNative<clap_plugin_descriptor_t *>(wasmP, native.desc);
		translate->assignWasmToNative_clap_plugin_t_plugin_data(wasmP + 4, native.plugin_data);
		translate->assignWasmToNative_ii(wasmP + 8, native.init); // bool init()
		translate->assignWasmToNative_vi(wasmP + 12, native.destroy); // void destroy()
		translate->assignWasmToNative_iiFii(wasmP + 16, native.activate); // bool activate()
		translate->assignWasmToNative_vi(wasmP + 20, native.deactivate); // void deactivate()
		translate->assignWasmToNative_ii(wasmP + 24, native.start_processing); // bool start_processing()
		translate->assignWasmToNative_vi(wasmP + 28, native.stop_processing); // void stop_processing()
		translate->assignWasmToNative_vi(wasmP + 32, native.reset); // void reset()
		translate->assignWasmToNative_iii(wasmP + 36, native.process); // int32_t process()
		translate->assignWasmToNative_clap_plugin_t_get_extension(wasmP + 40, native.get_extension);
		translate->assignWasmToNative_vi(wasmP + 44, native.on_main_thread); // void on_main_thread()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_t &native, WasmType wasmP) {
		translate->assignNativeToWasm<uint32_t>(native.desc, wasmP);
		translate->assignNativeToWasm_clap_plugin_t_plugin_data(native.plugin_data, wasmP + 4);
		translate->assignNativeToWasm_ii(native.init, wasmP + 8); // bool init(clap_plugin_t *)
		translate->assignNativeToWasm_vi(native.destroy, wasmP + 12); // void destroy(clap_plugin_t *)
		translate->assignNativeToWasm_iiFii(native.activate, wasmP + 16); // bool activate(clap_plugin_t *,double,uint32_t,uint32_t)
		translate->assignNativeToWasm_vi(native.deactivate, wasmP + 20); // void deactivate(clap_plugin_t *)
		translate->assignNativeToWasm_ii(native.start_processing, wasmP + 24); // bool start_processing(clap_plugin_t *)
		translate->assignNativeToWasm_vi(native.stop_processing, wasmP + 28); // void stop_processing(clap_plugin_t *)
		translate->assignNativeToWasm_vi(native.reset, wasmP + 32); // void reset(clap_plugin_t *)
		translate->assignNativeToWasm_iii(native.process, wasmP + 36); // int32_t process(clap_plugin_t *,clap_process_t *)
		translate->assignNativeToWasm_clap_plugin_t_get_extension(native.get_extension, wasmP + 40);
		translate->assignNativeToWasm_vi(native.on_main_thread, wasmP + 44); // void on_main_thread(clap_plugin_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_universal_plugin_id_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_universal_plugin_id_t &native) {
		translate->assignWasmToNative<const char *>(wasmP, native.abi);
		translate->assignWasmToNative<const char *>(wasmP, native.id);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_universal_plugin_id_t &native, WasmType wasmP) {
		translate->assignNativeToWasm<uint32_t>(native.abi, wasmP);
		translate->assignNativeToWasm<uint32_t>(native.id, wasmP);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_factory_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_factory_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.get_plugin_count); // uint32_t get_plugin_count()
		translate->assignWasmToNative_iii(wasmP + 4, native.get_plugin_descriptor); // clap_plugin_descriptor_t * get_plugin_descriptor()
		translate->assignWasmToNative_iiii(wasmP + 8, native.create_plugin); // clap_plugin_t * create_plugin()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_factory_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.get_plugin_count, wasmP); // uint32_t get_plugin_count(clap_plugin_factory_t *)
		translate->assignNativeToWasm_iii(native.get_plugin_descriptor, wasmP + 4); // clap_plugin_descriptor_t * get_plugin_descriptor(clap_plugin_factory_t *,uint32_t)
		translate->assignNativeToWasm_iiii(native.create_plugin, wasmP + 8); // clap_plugin_t * create_plugin(clap_plugin_factory_t *,clap_host_t *,const char *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_preset_discovery_metadata_receiver_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_preset_discovery_metadata_receiver_t &native) {
		translate->assignWasmToNative_clap_preset_discovery_metadata_receiver_t_receiver_data(wasmP, native.receiver_data);
		translate->assignWasmToNative_viii(wasmP + 4, native.on_error); // void on_error()
		translate->assignWasmToNative_iiii(wasmP + 8, native.begin_preset); // bool begin_preset()
		translate->assignWasmToNative_vii(wasmP + 12, native.add_plugin_id); // void add_plugin_id()
		translate->assignWasmToNative_vii(wasmP + 16, native.set_soundpack_id); // void set_soundpack_id()
		translate->assignWasmToNative_vii(wasmP + 20, native.set_flags); // void set_flags()
		translate->assignWasmToNative_vii(wasmP + 24, native.add_creator); // void add_creator()
		translate->assignWasmToNative_vii(wasmP + 28, native.set_description); // void set_description()
		translate->assignWasmToNative_viII(wasmP + 32, native.set_timestamps); // void set_timestamps()
		translate->assignWasmToNative_vii(wasmP + 36, native.add_feature); // void add_feature()
		translate->assignWasmToNative_viii(wasmP + 40, native.add_extra_info); // void add_extra_info()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_preset_discovery_metadata_receiver_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_preset_discovery_metadata_receiver_t_receiver_data(native.receiver_data, wasmP);
		translate->assignNativeToWasm_viii(native.on_error, wasmP + 4); // void on_error(clap_preset_discovery_metadata_receiver_t *,int32_t,const char *)
		translate->assignNativeToWasm_iiii(native.begin_preset, wasmP + 8); // bool begin_preset(clap_preset_discovery_metadata_receiver_t *,const char *,const char *)
		translate->assignNativeToWasm_vii(native.add_plugin_id, wasmP + 12); // void add_plugin_id(clap_preset_discovery_metadata_receiver_t *,clap_universal_plugin_id_t *)
		translate->assignNativeToWasm_vii(native.set_soundpack_id, wasmP + 16); // void set_soundpack_id(clap_preset_discovery_metadata_receiver_t *,const char *)
		translate->assignNativeToWasm_vii(native.set_flags, wasmP + 20); // void set_flags(clap_preset_discovery_metadata_receiver_t *,uint32_t)
		translate->assignNativeToWasm_vii(native.add_creator, wasmP + 24); // void add_creator(clap_preset_discovery_metadata_receiver_t *,const char *)
		translate->assignNativeToWasm_vii(native.set_description, wasmP + 28); // void set_description(clap_preset_discovery_metadata_receiver_t *,const char *)
		translate->assignNativeToWasm_viII(native.set_timestamps, wasmP + 32); // void set_timestamps(clap_preset_discovery_metadata_receiver_t *,uint64_t,uint64_t)
		translate->assignNativeToWasm_vii(native.add_feature, wasmP + 36); // void add_feature(clap_preset_discovery_metadata_receiver_t *,const char *)
		translate->assignNativeToWasm_viii(native.add_extra_info, wasmP + 40); // void add_extra_info(clap_preset_discovery_metadata_receiver_t *,const char *,const char *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_preset_discovery_filetype_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_preset_discovery_filetype_t &native) {
		translate->assignWasmToNative<const char *>(wasmP, native.name);
		translate->assignWasmToNative<const char *>(wasmP, native.description);
		translate->assignWasmToNative<const char *>(wasmP, native.file_extension);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_preset_discovery_filetype_t &native, WasmType wasmP) {
		translate->assignNativeToWasm<uint32_t>(native.name, wasmP);
		translate->assignNativeToWasm<uint32_t>(native.description, wasmP);
		translate->assignNativeToWasm<uint32_t>(native.file_extension, wasmP);
	}
};
template<>
struct Wclap::TranslateStruct<clap_preset_discovery_location_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_preset_discovery_location_t &native) {
		translate->assignWasmToNativeDirect<uint32_t>(wasmP, native.flags);
		translate->assignWasmToNative<const char *>(wasmP + 4, native.name);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 4, native.kind);
		translate->assignWasmToNative<const char *>(wasmP + 8, native.location);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_preset_discovery_location_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<uint32_t>(native.flags, wasmP);
		translate->assignNativeToWasm<uint32_t>(native.name, wasmP + 4);
		translate->assignNativeToWasmDirect<uint32_t>(native.kind, wasmP + 4);
		translate->assignNativeToWasm<uint32_t>(native.location, wasmP + 8);
	}
};
template<>
struct Wclap::TranslateStruct<clap_preset_discovery_soundpack_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_preset_discovery_soundpack_t &native) {
		translate->assignWasmToNativeDirect<uint32_t>(wasmP, native.flags);
		translate->assignWasmToNative<const char *>(wasmP + 4, native.id);
		translate->assignWasmToNative<const char *>(wasmP + 4, native.name);
		translate->assignWasmToNative<const char *>(wasmP + 4, native.description);
		translate->assignWasmToNative<const char *>(wasmP + 4, native.homepage_url);
		translate->assignWasmToNative<const char *>(wasmP + 4, native.vendor);
		translate->assignWasmToNative<const char *>(wasmP + 4, native.image_path);
		translate->assignWasmToNativeDirect<uint64_t>(wasmP + 8, native.release_timestamp);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_preset_discovery_soundpack_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<uint32_t>(native.flags, wasmP);
		translate->assignNativeToWasm<uint32_t>(native.id, wasmP + 4);
		translate->assignNativeToWasm<uint32_t>(native.name, wasmP + 4);
		translate->assignNativeToWasm<uint32_t>(native.description, wasmP + 4);
		translate->assignNativeToWasm<uint32_t>(native.homepage_url, wasmP + 4);
		translate->assignNativeToWasm<uint32_t>(native.vendor, wasmP + 4);
		translate->assignNativeToWasm<uint32_t>(native.image_path, wasmP + 4);
		translate->assignNativeToWasmDirect<uint64_t>(native.release_timestamp, wasmP + 8);
	}
};
template<>
struct Wclap::TranslateStruct<clap_preset_discovery_provider_descriptor_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_preset_discovery_provider_descriptor_t &native) {
		translate->assignWasmToNativeDirect<clap_version_t>(wasmP, native.clap_version);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.id);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.name);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.vendor);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_preset_discovery_provider_descriptor_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<clap_version_t>(native.clap_version, wasmP);
		translate->assignNativeToWasm<uint32_t>(native.id, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.name, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.vendor, wasmP + 12);
	}
};
template<>
struct Wclap::TranslateStruct<clap_preset_discovery_provider_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_preset_discovery_provider_t &native) {
		translate->assignWasmToNative<clap_preset_discovery_provider_descriptor_t *>(wasmP, native.desc);
		translate->assignWasmToNative_clap_preset_discovery_provider_t_provider_data(wasmP + 4, native.provider_data);
		translate->assignWasmToNative_ii(wasmP + 8, native.init); // bool init()
		translate->assignWasmToNative_vi(wasmP + 12, native.destroy); // void destroy()
		translate->assignWasmToNative_iiiii(wasmP + 16, native.get_metadata); // bool get_metadata()
		translate->assignWasmToNative_clap_preset_discovery_provider_t_get_extension(wasmP + 20, native.get_extension);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_preset_discovery_provider_t &native, WasmType wasmP) {
		translate->assignNativeToWasm<uint32_t>(native.desc, wasmP);
		translate->assignNativeToWasm_clap_preset_discovery_provider_t_provider_data(native.provider_data, wasmP + 4);
		translate->assignNativeToWasm_ii(native.init, wasmP + 8); // bool init(clap_preset_discovery_provider_t *)
		translate->assignNativeToWasm_vi(native.destroy, wasmP + 12); // void destroy(clap_preset_discovery_provider_t *)
		translate->assignNativeToWasm_iiiii(native.get_metadata, wasmP + 16); // bool get_metadata(clap_preset_discovery_provider_t *,uint32_t,const char *,clap_preset_discovery_metadata_receiver_t *)
		translate->assignNativeToWasm_clap_preset_discovery_provider_t_get_extension(native.get_extension, wasmP + 20);
	}
};
template<>
struct Wclap::TranslateStruct<clap_preset_discovery_indexer_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_preset_discovery_indexer_t &native) {
		translate->assignWasmToNativeDirect<clap_version_t>(wasmP, native.clap_version);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.name);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.vendor);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.url);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.version);
		translate->assignWasmToNative_clap_preset_discovery_indexer_t_indexer_data(wasmP + 12, native.indexer_data);
		translate->assignWasmToNative_iii(wasmP + 16, native.declare_filetype); // bool declare_filetype()
		translate->assignWasmToNative_iii(wasmP + 20, native.declare_location); // bool declare_location()
		translate->assignWasmToNative_iii(wasmP + 24, native.declare_soundpack); // bool declare_soundpack()
		translate->assignWasmToNative_clap_preset_discovery_indexer_t_get_extension(wasmP + 28, native.get_extension);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_preset_discovery_indexer_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<clap_version_t>(native.clap_version, wasmP);
		translate->assignNativeToWasm<uint32_t>(native.name, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.vendor, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.url, wasmP + 12);
		translate->assignNativeToWasm<uint32_t>(native.version, wasmP + 12);
		translate->assignNativeToWasm_clap_preset_discovery_indexer_t_indexer_data(native.indexer_data, wasmP + 12);
		translate->assignNativeToWasm_iii(native.declare_filetype, wasmP + 16); // bool declare_filetype(clap_preset_discovery_indexer_t *,clap_preset_discovery_filetype_t *)
		translate->assignNativeToWasm_iii(native.declare_location, wasmP + 20); // bool declare_location(clap_preset_discovery_indexer_t *,clap_preset_discovery_location_t *)
		translate->assignNativeToWasm_iii(native.declare_soundpack, wasmP + 24); // bool declare_soundpack(clap_preset_discovery_indexer_t *,clap_preset_discovery_soundpack_t *)
		translate->assignNativeToWasm_clap_preset_discovery_indexer_t_get_extension(native.get_extension, wasmP + 28);
	}
};
template<>
struct Wclap::TranslateStruct<clap_preset_discovery_factory_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_preset_discovery_factory_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.count); // uint32_t count()
		translate->assignWasmToNative_iii(wasmP + 4, native.get_descriptor); // clap_preset_discovery_provider_descriptor_t * get_descriptor()
		translate->assignWasmToNative_iiii(wasmP + 8, native.create); // clap_preset_discovery_provider_t * create()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_preset_discovery_factory_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.count, wasmP); // uint32_t count(clap_preset_discovery_factory_t *)
		translate->assignNativeToWasm_iii(native.get_descriptor, wasmP + 4); // clap_preset_discovery_provider_descriptor_t * get_descriptor(clap_preset_discovery_factory_t *,uint32_t)
		translate->assignNativeToWasm_iiii(native.create, wasmP + 8); // clap_preset_discovery_provider_t * create(clap_preset_discovery_factory_t *,clap_preset_discovery_indexer_t *,const char *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_ambisonic_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_ambisonic_t &native) {
		translate->assignWasmToNative_iii(wasmP, native.is_config_supported); // bool is_config_supported()
		translate->assignWasmToNative_iiiii(wasmP + 4, native.get_config); // bool get_config()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_ambisonic_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iii(native.is_config_supported, wasmP); // bool is_config_supported(clap_plugin_t *,clap_ambisonic_config_t *)
		translate->assignNativeToWasm_iiiii(native.get_config, wasmP + 4); // bool get_config(clap_plugin_t *,bool,uint32_t,clap_ambisonic_config_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_ambisonic_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_ambisonic_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.changed); // void changed()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_ambisonic_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.changed, wasmP); // void changed(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_audio_port_info_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_audio_port_info_t &native) {
		translate->assignWasmToNativeDirect<uint32_t>(wasmP, native.id);
		for (size_t a = 0; a < 256; ++a) {
			translate->assignWasmToNativeDirect<char>(wasmP + 4 + a, native.name[a]);
		}
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 260, native.flags);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 264, native.channel_count);
		translate->assignWasmToNative<const char *>(wasmP + 268, native.port_type);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 268, native.in_place_pair);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_audio_port_info_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<uint32_t>(native.id, wasmP);
		for (size_t a = 0; a < 256; ++a) {
			translate->assignNativeToWasmDirect<char>(native.name[a], wasmP + 4 + a);
		}
		translate->assignNativeToWasmDirect<uint32_t>(native.flags, wasmP + 260);
		translate->assignNativeToWasmDirect<uint32_t>(native.channel_count, wasmP + 264);
		translate->assignNativeToWasm<uint32_t>(native.port_type, wasmP + 268);
		translate->assignNativeToWasmDirect<uint32_t>(native.in_place_pair, wasmP + 268);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_audio_ports_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_audio_ports_t &native) {
		translate->assignWasmToNative_iii(wasmP, native.count); // uint32_t count()
		translate->assignWasmToNative_iiiii(wasmP + 4, native.get); // bool get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_audio_ports_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iii(native.count, wasmP); // uint32_t count(clap_plugin_t *,bool)
		translate->assignNativeToWasm_iiiii(native.get, wasmP + 4); // bool get(clap_plugin_t *,uint32_t,bool,clap_audio_port_info_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_audio_ports_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_audio_ports_t &native) {
		translate->assignWasmToNative_iii(wasmP, native.is_rescan_flag_supported); // bool is_rescan_flag_supported()
		translate->assignWasmToNative_vii(wasmP + 4, native.rescan); // void rescan()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_audio_ports_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iii(native.is_rescan_flag_supported, wasmP); // bool is_rescan_flag_supported(clap_host_t *,uint32_t)
		translate->assignNativeToWasm_vii(native.rescan, wasmP + 4); // void rescan(clap_host_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_audio_ports_activation_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_audio_ports_activation_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.can_activate_while_processing); // bool can_activate_while_processing()
		translate->assignWasmToNative_iiiiii(wasmP + 4, native.set_active); // bool set_active()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_audio_ports_activation_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.can_activate_while_processing, wasmP); // bool can_activate_while_processing(clap_plugin_t *)
		translate->assignNativeToWasm_iiiiii(native.set_active, wasmP + 4); // bool set_active(clap_plugin_t *,bool,uint32_t,bool,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_audio_ports_config_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_audio_ports_config_t &native) {
		translate->assignWasmToNativeDirect<uint32_t>(wasmP, native.id);
		for (size_t a = 0; a < 256; ++a) {
			translate->assignWasmToNativeDirect<char>(wasmP + 4 + a, native.name[a]);
		}
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 260, native.input_port_count);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 264, native.output_port_count);
		translate->assignWasmToNativeDirect<bool>(wasmP + 268, native.has_main_input);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 272, native.main_input_channel_count);
		translate->assignWasmToNative<const char *>(wasmP + 276, native.main_input_port_type);
		translate->assignWasmToNativeDirect<bool>(wasmP + 273, native.has_main_output);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 276, native.main_output_channel_count);
		translate->assignWasmToNative<const char *>(wasmP + 280, native.main_output_port_type);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_audio_ports_config_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<uint32_t>(native.id, wasmP);
		for (size_t a = 0; a < 256; ++a) {
			translate->assignNativeToWasmDirect<char>(native.name[a], wasmP + 4 + a);
		}
		translate->assignNativeToWasmDirect<uint32_t>(native.input_port_count, wasmP + 260);
		translate->assignNativeToWasmDirect<uint32_t>(native.output_port_count, wasmP + 264);
		translate->assignNativeToWasmDirect<bool>(native.has_main_input, wasmP + 268);
		translate->assignNativeToWasmDirect<uint32_t>(native.main_input_channel_count, wasmP + 272);
		translate->assignNativeToWasm<uint32_t>(native.main_input_port_type, wasmP + 276);
		translate->assignNativeToWasmDirect<bool>(native.has_main_output, wasmP + 273);
		translate->assignNativeToWasmDirect<uint32_t>(native.main_output_channel_count, wasmP + 276);
		translate->assignNativeToWasm<uint32_t>(native.main_output_port_type, wasmP + 280);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_audio_ports_config_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_audio_ports_config_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.count); // uint32_t count()
		translate->assignWasmToNative_iiii(wasmP + 4, native.get); // bool get()
		translate->assignWasmToNative_iii(wasmP + 8, native.select); // bool select()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_audio_ports_config_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.count, wasmP); // uint32_t count(clap_plugin_t *)
		translate->assignNativeToWasm_iiii(native.get, wasmP + 4); // bool get(clap_plugin_t *,uint32_t,clap_audio_ports_config_t *)
		translate->assignNativeToWasm_iii(native.select, wasmP + 8); // bool select(clap_plugin_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_audio_ports_config_info_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_audio_ports_config_info_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.current_config); // uint32_t current_config()
		translate->assignWasmToNative_iiiiii(wasmP + 4, native.get); // bool get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_audio_ports_config_info_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.current_config, wasmP); // uint32_t current_config(clap_plugin_t *)
		translate->assignNativeToWasm_iiiiii(native.get, wasmP + 4); // bool get(clap_plugin_t *,uint32_t,uint32_t,bool,clap_audio_port_info_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_audio_ports_config_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_audio_ports_config_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.rescan); // void rescan()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_audio_ports_config_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.rescan, wasmP); // void rescan(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_audio_port_configuration_request_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_audio_port_configuration_request_t &native) {
		translate->assignWasmToNativeDirect<bool>(wasmP, native.is_input);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 4, native.port_index);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 8, native.channel_count);
		translate->assignWasmToNative<const char *>(wasmP + 12, native.port_type);
		translate->assignWasmToNative_clap_audio_port_configuration_request_t_port_details(wasmP + 12, native.port_details);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_audio_port_configuration_request_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<bool>(native.is_input, wasmP);
		translate->assignNativeToWasmDirect<uint32_t>(native.port_index, wasmP + 4);
		translate->assignNativeToWasmDirect<uint32_t>(native.channel_count, wasmP + 8);
		translate->assignNativeToWasm<uint32_t>(native.port_type, wasmP + 12);
		translate->assignNativeToWasm_clap_audio_port_configuration_request_t_port_details(native.port_details, wasmP + 12);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_configurable_audio_ports_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_configurable_audio_ports_t &native) {
		translate->assignWasmToNative_iiii(wasmP, native.can_apply_configuration); // bool can_apply_configuration()
		translate->assignWasmToNative_iiii(wasmP + 4, native.apply_configuration); // bool apply_configuration()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_configurable_audio_ports_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iiii(native.can_apply_configuration, wasmP); // bool can_apply_configuration(clap_plugin_t *,clap_audio_port_configuration_request_t *,uint32_t)
		translate->assignNativeToWasm_iiii(native.apply_configuration, wasmP + 4); // bool apply_configuration(clap_plugin_t *,clap_audio_port_configuration_request_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_context_menu_entry_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_context_menu_entry_t &native) {
		translate->assignWasmToNative<const char *>(wasmP, native.label);
		translate->assignWasmToNativeDirect<bool>(wasmP, native.is_enabled);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 4, native.action_id);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_context_menu_entry_t &native, WasmType wasmP) {
		translate->assignNativeToWasm<uint32_t>(native.label, wasmP);
		translate->assignNativeToWasmDirect<bool>(native.is_enabled, wasmP);
		translate->assignNativeToWasmDirect<uint32_t>(native.action_id, wasmP + 4);
	}
};
template<>
struct Wclap::TranslateStruct<clap_context_menu_check_entry_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_context_menu_check_entry_t &native) {
		translate->assignWasmToNative<const char *>(wasmP, native.label);
		translate->assignWasmToNativeDirect<bool>(wasmP, native.is_enabled);
		translate->assignWasmToNativeDirect<bool>(wasmP + 1, native.is_checked);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 4, native.action_id);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_context_menu_check_entry_t &native, WasmType wasmP) {
		translate->assignNativeToWasm<uint32_t>(native.label, wasmP);
		translate->assignNativeToWasmDirect<bool>(native.is_enabled, wasmP);
		translate->assignNativeToWasmDirect<bool>(native.is_checked, wasmP + 1);
		translate->assignNativeToWasmDirect<uint32_t>(native.action_id, wasmP + 4);
	}
};
template<>
struct Wclap::TranslateStruct<clap_context_menu_item_title_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_context_menu_item_title_t &native) {
		translate->assignWasmToNative<const char *>(wasmP, native.title);
		translate->assignWasmToNativeDirect<bool>(wasmP, native.is_enabled);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_context_menu_item_title_t &native, WasmType wasmP) {
		translate->assignNativeToWasm<uint32_t>(native.title, wasmP);
		translate->assignNativeToWasmDirect<bool>(native.is_enabled, wasmP);
	}
};
template<>
struct Wclap::TranslateStruct<clap_context_menu_submenu_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_context_menu_submenu_t &native) {
		translate->assignWasmToNative<const char *>(wasmP, native.label);
		translate->assignWasmToNativeDirect<bool>(wasmP, native.is_enabled);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_context_menu_submenu_t &native, WasmType wasmP) {
		translate->assignNativeToWasm<uint32_t>(native.label, wasmP);
		translate->assignNativeToWasmDirect<bool>(native.is_enabled, wasmP);
	}
};
template<>
struct Wclap::TranslateStruct<clap_context_menu_builder_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_context_menu_builder_t &native) {
		translate->assignWasmToNative_clap_context_menu_builder_t_ctx(wasmP, native.ctx);
		translate->assignWasmToNative_clap_context_menu_builder_t_add_item(wasmP + 4, native.add_item);
		translate->assignWasmToNative_iii(wasmP + 8, native.supports); // bool supports()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_context_menu_builder_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_context_menu_builder_t_ctx(native.ctx, wasmP);
		translate->assignNativeToWasm_clap_context_menu_builder_t_add_item(native.add_item, wasmP + 4);
		translate->assignNativeToWasm_iii(native.supports, wasmP + 8); // bool supports(clap_context_menu_builder_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_context_menu_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_context_menu_t &native) {
		translate->assignWasmToNative_iiii(wasmP, native.populate); // bool populate()
		translate->assignWasmToNative_iiii(wasmP + 4, native.perform); // bool perform()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_context_menu_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iiii(native.populate, wasmP); // bool populate(clap_plugin_t *,clap_context_menu_target_t *,clap_context_menu_builder_t *)
		translate->assignNativeToWasm_iiii(native.perform, wasmP + 4); // bool perform(clap_plugin_t *,clap_context_menu_target_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_context_menu_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_context_menu_t &native) {
		translate->assignWasmToNative_iiii(wasmP, native.populate); // bool populate()
		translate->assignWasmToNative_iiii(wasmP + 4, native.perform); // bool perform()
		translate->assignWasmToNative_ii(wasmP + 8, native.can_popup); // bool can_popup()
		translate->assignWasmToNative_iiiiii(wasmP + 12, native.popup); // bool popup()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_context_menu_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iiii(native.populate, wasmP); // bool populate(clap_host_t *,clap_context_menu_target_t *,clap_context_menu_builder_t *)
		translate->assignNativeToWasm_iiii(native.perform, wasmP + 4); // bool perform(clap_host_t *,clap_context_menu_target_t *,uint32_t)
		translate->assignNativeToWasm_ii(native.can_popup, wasmP + 8); // bool can_popup(clap_host_t *)
		translate->assignNativeToWasm_iiiiii(native.popup, wasmP + 12); // bool popup(clap_host_t *,clap_context_menu_target_t *,int32_t,int32_t,int32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_event_registry_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_event_registry_t &native) {
		translate->assignWasmToNative_clap_host_event_registry_t_query(wasmP, native.query);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_event_registry_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_host_event_registry_t_query(native.query, wasmP);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_gui_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_gui_t &native) {
		translate->assignWasmToNative_iiii(wasmP, native.is_api_supported); // bool is_api_supported()
		translate->assignWasmToNative_clap_plugin_gui_t_get_preferred_api(wasmP + 4, native.get_preferred_api);
		translate->assignWasmToNative_iiii(wasmP + 8, native.create); // bool create()
		translate->assignWasmToNative_vi(wasmP + 12, native.destroy); // void destroy()
		translate->assignWasmToNative_iiF(wasmP + 16, native.set_scale); // bool set_scale()
		translate->assignWasmToNative_clap_plugin_gui_t_get_size(wasmP + 20, native.get_size);
		translate->assignWasmToNative_ii(wasmP + 24, native.can_resize); // bool can_resize()
		translate->assignWasmToNative_iii(wasmP + 28, native.get_resize_hints); // bool get_resize_hints()
		translate->assignWasmToNative_clap_plugin_gui_t_adjust_size(wasmP + 32, native.adjust_size);
		translate->assignWasmToNative_iiii(wasmP + 36, native.set_size); // bool set_size()
		translate->assignWasmToNative_iii(wasmP + 40, native.set_parent); // bool set_parent()
		translate->assignWasmToNative_iii(wasmP + 44, native.set_transient); // bool set_transient()
		translate->assignWasmToNative_vii(wasmP + 48, native.suggest_title); // void suggest_title()
		translate->assignWasmToNative_ii(wasmP + 52, native.show); // bool show()
		translate->assignWasmToNative_ii(wasmP + 56, native.hide); // bool hide()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_gui_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iiii(native.is_api_supported, wasmP); // bool is_api_supported(clap_plugin_t *,const char *,bool)
		translate->assignNativeToWasm_clap_plugin_gui_t_get_preferred_api(native.get_preferred_api, wasmP + 4);
		translate->assignNativeToWasm_iiii(native.create, wasmP + 8); // bool create(clap_plugin_t *,const char *,bool)
		translate->assignNativeToWasm_vi(native.destroy, wasmP + 12); // void destroy(clap_plugin_t *)
		translate->assignNativeToWasm_iiF(native.set_scale, wasmP + 16); // bool set_scale(clap_plugin_t *,double)
		translate->assignNativeToWasm_clap_plugin_gui_t_get_size(native.get_size, wasmP + 20);
		translate->assignNativeToWasm_ii(native.can_resize, wasmP + 24); // bool can_resize(clap_plugin_t *)
		translate->assignNativeToWasm_iii(native.get_resize_hints, wasmP + 28); // bool get_resize_hints(clap_plugin_t *,clap_gui_resize_hints_t *)
		translate->assignNativeToWasm_clap_plugin_gui_t_adjust_size(native.adjust_size, wasmP + 32);
		translate->assignNativeToWasm_iiii(native.set_size, wasmP + 36); // bool set_size(clap_plugin_t *,uint32_t,uint32_t)
		translate->assignNativeToWasm_iii(native.set_parent, wasmP + 40); // bool set_parent(clap_plugin_t *,clap_window_t *)
		translate->assignNativeToWasm_iii(native.set_transient, wasmP + 44); // bool set_transient(clap_plugin_t *,clap_window_t *)
		translate->assignNativeToWasm_vii(native.suggest_title, wasmP + 48); // void suggest_title(clap_plugin_t *,const char *)
		translate->assignNativeToWasm_ii(native.show, wasmP + 52); // bool show(clap_plugin_t *)
		translate->assignNativeToWasm_ii(native.hide, wasmP + 56); // bool hide(clap_plugin_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_gui_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_gui_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.resize_hints_changed); // void resize_hints_changed()
		translate->assignWasmToNative_iiii(wasmP + 4, native.request_resize); // bool request_resize()
		translate->assignWasmToNative_ii(wasmP + 8, native.request_show); // bool request_show()
		translate->assignWasmToNative_ii(wasmP + 12, native.request_hide); // bool request_hide()
		translate->assignWasmToNative_vii(wasmP + 16, native.closed); // void closed()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_gui_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.resize_hints_changed, wasmP); // void resize_hints_changed(clap_host_t *)
		translate->assignNativeToWasm_iiii(native.request_resize, wasmP + 4); // bool request_resize(clap_host_t *,uint32_t,uint32_t)
		translate->assignNativeToWasm_ii(native.request_show, wasmP + 8); // bool request_show(clap_host_t *)
		translate->assignNativeToWasm_ii(native.request_hide, wasmP + 12); // bool request_hide(clap_host_t *)
		translate->assignNativeToWasm_vii(native.closed, wasmP + 16); // void closed(clap_host_t *,bool)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_latency_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_latency_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.get); // uint32_t get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_latency_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.get, wasmP); // uint32_t get(clap_plugin_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_latency_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_latency_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.changed); // void changed()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_latency_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.changed, wasmP); // void changed(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_log_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_log_t &native) {
		translate->assignWasmToNative_viii(wasmP, native.log); // void log()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_log_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_viii(native.log, wasmP); // void log(clap_host_t *,int32_t,const char *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_note_name_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_note_name_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.count); // uint32_t count()
		translate->assignWasmToNative_iiii(wasmP + 4, native.get); // bool get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_note_name_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.count, wasmP); // uint32_t count(clap_plugin_t *)
		translate->assignNativeToWasm_iiii(native.get, wasmP + 4); // bool get(clap_plugin_t *,uint32_t,clap_note_name_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_note_name_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_note_name_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.changed); // void changed()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_note_name_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.changed, wasmP); // void changed(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_note_ports_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_note_ports_t &native) {
		translate->assignWasmToNative_iii(wasmP, native.count); // uint32_t count()
		translate->assignWasmToNative_iiiii(wasmP + 4, native.get); // bool get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_note_ports_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iii(native.count, wasmP); // uint32_t count(clap_plugin_t *,bool)
		translate->assignNativeToWasm_iiiii(native.get, wasmP + 4); // bool get(clap_plugin_t *,uint32_t,bool,clap_note_port_info_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_note_ports_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_note_ports_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.supported_dialects); // uint32_t supported_dialects()
		translate->assignWasmToNative_vii(wasmP + 4, native.rescan); // void rescan()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_note_ports_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.supported_dialects, wasmP); // uint32_t supported_dialects(clap_host_t *)
		translate->assignNativeToWasm_vii(native.rescan, wasmP + 4); // void rescan(clap_host_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_param_indication_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_param_indication_t &native) {
		translate->assignWasmToNative_viiiiii(wasmP, native.set_mapping); // void set_mapping()
		translate->assignWasmToNative_viiii(wasmP + 4, native.set_automation); // void set_automation()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_param_indication_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_viiiiii(native.set_mapping, wasmP); // void set_mapping(clap_plugin_t *,uint32_t,bool,clap_color_t *,const char *,const char *)
		translate->assignNativeToWasm_viiii(native.set_automation, wasmP + 4); // void set_automation(clap_plugin_t *,uint32_t,uint32_t,clap_color_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_param_info_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_param_info_t &native) {
		translate->assignWasmToNativeDirect<uint32_t>(wasmP, native.id);
		translate->assignWasmToNativeDirect<uint32_t>(wasmP + 4, native.flags);
		translate->assignWasmToNative_clap_param_info_t_cookie(wasmP + 8, native.cookie);
		for (size_t a = 0; a < 256; ++a) {
			translate->assignWasmToNativeDirect<char>(wasmP + 12 + a, native.name[a]);
		}
		for (size_t a = 0; a < 1024; ++a) {
			translate->assignWasmToNativeDirect<char>(wasmP + 268 + a, native.module[a]);
		}
		translate->assignWasmToNativeDirect<double>(wasmP + 1296, native.min_value);
		translate->assignWasmToNativeDirect<double>(wasmP + 1304, native.max_value);
		translate->assignWasmToNativeDirect<double>(wasmP + 1312, native.default_value);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_param_info_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<uint32_t>(native.id, wasmP);
		translate->assignNativeToWasmDirect<uint32_t>(native.flags, wasmP + 4);
		translate->assignNativeToWasm_clap_param_info_t_cookie(native.cookie, wasmP + 8);
		for (size_t a = 0; a < 256; ++a) {
			translate->assignNativeToWasmDirect<char>(native.name[a], wasmP + 12 + a);
		}
		for (size_t a = 0; a < 1024; ++a) {
			translate->assignNativeToWasmDirect<char>(native.module[a], wasmP + 268 + a);
		}
		translate->assignNativeToWasmDirect<double>(native.min_value, wasmP + 1296);
		translate->assignNativeToWasmDirect<double>(native.max_value, wasmP + 1304);
		translate->assignNativeToWasmDirect<double>(native.default_value, wasmP + 1312);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_params_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_params_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.count); // uint32_t count()
		translate->assignWasmToNative_iiii(wasmP + 4, native.get_info); // bool get_info()
		translate->assignWasmToNative_clap_plugin_params_t_get_value(wasmP + 8, native.get_value);
		translate->assignWasmToNative_clap_plugin_params_t_value_to_text(wasmP + 12, native.value_to_text);
		translate->assignWasmToNative_clap_plugin_params_t_text_to_value(wasmP + 16, native.text_to_value);
		translate->assignWasmToNative_viii(wasmP + 20, native.flush); // void flush()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_params_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.count, wasmP); // uint32_t count(clap_plugin_t *)
		translate->assignNativeToWasm_iiii(native.get_info, wasmP + 4); // bool get_info(clap_plugin_t *,uint32_t,clap_param_info_t *)
		translate->assignNativeToWasm_clap_plugin_params_t_get_value(native.get_value, wasmP + 8);
		translate->assignNativeToWasm_clap_plugin_params_t_value_to_text(native.value_to_text, wasmP + 12);
		translate->assignNativeToWasm_clap_plugin_params_t_text_to_value(native.text_to_value, wasmP + 16);
		translate->assignNativeToWasm_viii(native.flush, wasmP + 20); // void flush(clap_plugin_t *,clap_input_events_t *,clap_output_events_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_params_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_params_t &native) {
		translate->assignWasmToNative_vii(wasmP, native.rescan); // void rescan()
		translate->assignWasmToNative_viii(wasmP + 4, native.clear); // void clear()
		translate->assignWasmToNative_vi(wasmP + 8, native.request_flush); // void request_flush()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_params_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vii(native.rescan, wasmP); // void rescan(clap_host_t *,uint32_t)
		translate->assignNativeToWasm_viii(native.clear, wasmP + 4); // void clear(clap_host_t *,uint32_t,uint32_t)
		translate->assignNativeToWasm_vi(native.request_flush, wasmP + 8); // void request_flush(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_preset_load_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_preset_load_t &native) {
		translate->assignWasmToNative_iiiii(wasmP, native.from_location); // bool from_location()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_preset_load_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iiiii(native.from_location, wasmP); // bool from_location(clap_plugin_t *,uint32_t,const char *,const char *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_preset_load_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_preset_load_t &native) {
		translate->assignWasmToNative_viiiiii(wasmP, native.on_error); // void on_error()
		translate->assignWasmToNative_viiii(wasmP + 4, native.loaded); // void loaded()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_preset_load_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_viiiiii(native.on_error, wasmP); // void on_error(clap_host_t *,uint32_t,const char *,const char *,int32_t,const char *)
		translate->assignNativeToWasm_viiii(native.loaded, wasmP + 4); // void loaded(clap_host_t *,uint32_t,const char *,const char *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_remote_controls_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_remote_controls_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.count); // uint32_t count()
		translate->assignWasmToNative_iiii(wasmP + 4, native.get); // bool get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_remote_controls_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.count, wasmP); // uint32_t count(clap_plugin_t *)
		translate->assignNativeToWasm_iiii(native.get, wasmP + 4); // bool get(clap_plugin_t *,uint32_t,clap_remote_controls_page_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_remote_controls_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_remote_controls_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.changed); // void changed()
		translate->assignWasmToNative_vii(wasmP + 4, native.suggest_page); // void suggest_page()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_remote_controls_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.changed, wasmP); // void changed(clap_host_t *)
		translate->assignNativeToWasm_vii(native.suggest_page, wasmP + 4); // void suggest_page(clap_host_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_render_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_render_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.has_hard_realtime_requirement); // bool has_hard_realtime_requirement()
		translate->assignWasmToNative_iii(wasmP + 4, native.set); // bool set()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_render_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.has_hard_realtime_requirement, wasmP); // bool has_hard_realtime_requirement(clap_plugin_t *)
		translate->assignNativeToWasm_iii(native.set, wasmP + 4); // bool set(clap_plugin_t *,int32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_state_context_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_state_context_t &native) {
		translate->assignWasmToNative_iiii(wasmP, native.save); // bool save()
		translate->assignWasmToNative_iiii(wasmP + 4, native.load); // bool load()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_state_context_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iiii(native.save, wasmP); // bool save(clap_plugin_t *,clap_ostream_t *,uint32_t)
		translate->assignNativeToWasm_iiii(native.load, wasmP + 4); // bool load(clap_plugin_t *,clap_istream_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_state_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_state_t &native) {
		translate->assignWasmToNative_iii(wasmP, native.save); // bool save()
		translate->assignWasmToNative_iii(wasmP + 4, native.load); // bool load()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_state_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iii(native.save, wasmP); // bool save(clap_plugin_t *,clap_ostream_t *)
		translate->assignNativeToWasm_iii(native.load, wasmP + 4); // bool load(clap_plugin_t *,clap_istream_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_state_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_state_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.mark_dirty); // void mark_dirty()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_state_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.mark_dirty, wasmP); // void mark_dirty(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_surround_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_surround_t &native) {
		translate->assignWasmToNative_iiI(wasmP, native.is_channel_mask_supported); // bool is_channel_mask_supported()
		translate->assignWasmToNative_clap_plugin_surround_t_get_channel_map(wasmP + 4, native.get_channel_map);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_surround_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iiI(native.is_channel_mask_supported, wasmP); // bool is_channel_mask_supported(clap_plugin_t *,uint64_t)
		translate->assignNativeToWasm_clap_plugin_surround_t_get_channel_map(native.get_channel_map, wasmP + 4);
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_surround_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_surround_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.changed); // void changed()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_surround_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.changed, wasmP); // void changed(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_tail_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_tail_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.get); // uint32_t get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_tail_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.get, wasmP); // uint32_t get(clap_plugin_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_tail_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_tail_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.changed); // void changed()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_tail_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.changed, wasmP); // void changed(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_thread_check_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_thread_check_t &native) {
		translate->assignWasmToNative_ii(wasmP, native.is_main_thread); // bool is_main_thread()
		translate->assignWasmToNative_ii(wasmP + 4, native.is_audio_thread); // bool is_audio_thread()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_thread_check_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_ii(native.is_main_thread, wasmP); // bool is_main_thread(clap_host_t *)
		translate->assignNativeToWasm_ii(native.is_audio_thread, wasmP + 4); // bool is_audio_thread(clap_host_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_thread_pool_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_thread_pool_t &native) {
		translate->assignWasmToNative_vii(wasmP, native.exec); // void exec()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_thread_pool_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vii(native.exec, wasmP); // void exec(clap_plugin_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_thread_pool_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_thread_pool_t &native) {
		translate->assignWasmToNative_iii(wasmP, native.request_exec); // bool request_exec()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_thread_pool_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iii(native.request_exec, wasmP); // bool request_exec(clap_host_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_timer_support_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_timer_support_t &native) {
		translate->assignWasmToNative_vii(wasmP, native.on_timer); // void on_timer()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_timer_support_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vii(native.on_timer, wasmP); // void on_timer(clap_plugin_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_timer_support_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_timer_support_t &native) {
		translate->assignWasmToNative_clap_host_timer_support_t_register_timer(wasmP, native.register_timer);
		translate->assignWasmToNative_iii(wasmP + 4, native.unregister_timer); // bool unregister_timer()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_timer_support_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_clap_host_timer_support_t_register_timer(native.register_timer, wasmP);
		translate->assignNativeToWasm_iii(native.unregister_timer, wasmP + 4); // bool unregister_timer(clap_host_t *,uint32_t)
	}
};
template<>
struct Wclap::TranslateStruct<clap_track_info_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_track_info_t &native) {
		translate->assignWasmToNativeDirect<uint64_t>(wasmP, native.flags);
		for (size_t a = 0; a < 256; ++a) {
			translate->assignWasmToNativeDirect<char>(wasmP + 8 + a, native.name[a]);
		}
		translate->assignWasmToNativeDirect<clap_color_t>(wasmP + 264, native.color);
		translate->assignWasmToNativeDirect<int32_t>(wasmP + 268, native.audio_channel_count);
		translate->assignWasmToNative<const char *>(wasmP + 272, native.audio_port_type);
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_track_info_t &native, WasmType wasmP) {
		translate->assignNativeToWasmDirect<uint64_t>(native.flags, wasmP);
		for (size_t a = 0; a < 256; ++a) {
			translate->assignNativeToWasmDirect<char>(native.name[a], wasmP + 8 + a);
		}
		translate->assignNativeToWasmDirect<clap_color_t>(native.color, wasmP + 264);
		translate->assignNativeToWasmDirect<int32_t>(native.audio_channel_count, wasmP + 268);
		translate->assignNativeToWasm<uint32_t>(native.audio_port_type, wasmP + 272);
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_track_info_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_track_info_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.changed); // void changed()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_track_info_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.changed, wasmP); // void changed(clap_plugin_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_track_info_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_track_info_t &native) {
		translate->assignWasmToNative_iii(wasmP, native.get); // bool get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_track_info_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iii(native.get, wasmP); // bool get(clap_host_t *,clap_track_info_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_plugin_voice_info_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_plugin_voice_info_t &native) {
		translate->assignWasmToNative_iii(wasmP, native.get); // bool get()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_plugin_voice_info_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_iii(native.get, wasmP); // bool get(clap_plugin_t *,clap_voice_info_t *)
	}
};
template<>
struct Wclap::TranslateStruct<clap_host_voice_info_t> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, clap_host_voice_info_t &native) {
		translate->assignWasmToNative_vi(wasmP, native.changed); // void changed()
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const clap_host_voice_info_t &native, WasmType wasmP) {
		translate->assignNativeToWasm_vi(native.changed, wasmP); // void changed(clap_host_t *)
	}
};