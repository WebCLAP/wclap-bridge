/* Generated by translate-clap-api.js */

// Translate: clap_version_t *
template<>
struct Wclap::Translate<clap_version_t *> {
	using WasmType = uint32_t;
	// Translate the WASM pointer to a native one
	static clap_version_t * wasmToNative(Wasm *wasm, WasmType p) {
		if (!p) return nullptr;
		void *nativeInWasm = wasm_memory_data(wasm->memory) + p;
		return (clap_version_t *)nativeInWasm;
	}
	// Make a temporary copy in the WASM memory, and point to that
	static WasmType nativeToWasm(Wasm *wasm, clap_version_t *v) {
		if (!v) return 0;
		uint32_t wasmP = wasm->temporaryWasmBytes(sizeof(clap_version_t), alignof(clap_version_t));
		void *nativeInWasm = wasm_memory_data(wasm->memory) + p;
		*(clap_version_t *)nativeInWasm = *v;
		return wasmP;
	}
};
// Translate: clap_color_t *
template<>
struct Wclap::Translate<clap_color_t *> {
	using WasmType = uint32_t;
	// Translate the WASM pointer to a native one
	static clap_color_t * wasmToNative(Wasm *wasm, WasmType p) {
		if (!p) return nullptr;
		void *nativeInWasm = wasm_memory_data(wasm->memory) + p;
		return (clap_color_t *)nativeInWasm;
	}
	// Make a temporary copy in the WASM memory, and point to that
	static WasmType nativeToWasm(Wasm *wasm, clap_color_t *v) {
		if (!v) return 0;
		uint32_t wasmP = wasm->temporaryWasmBytes(sizeof(clap_color_t), alignof(clap_color_t));
		void *nativeInWasm = wasm_memory_data(wasm->memory) + p;
		*(clap_color_t *)nativeInWasm = *v;
		return wasmP;
	}
};