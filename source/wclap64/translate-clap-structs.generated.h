/* Generated by translate-clap-structs.js */
#pragma once
namespace wclap { namespace wclap64 {

using wclap_version = clap_version_t;

struct wclap_host {
	wclap_host(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 88;
	
	operator bool() const {
		return pointerInWasm;
	}

	clap_version_t & clap_version() {
		return *(clap_version_t *)pointerInWasm;
	}
	WasmP & host_data() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & name() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & vendor() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & url() {
		return *(WasmP *)(pointerInWasm + 40);
	}
	WasmP & version() {
		return *(WasmP *)(pointerInWasm + 48);
	}
	WasmP & get_extension() {
		return *(WasmP *)(pointerInWasm + 56);
	}
	WasmP & request_restart() {
		return *(WasmP *)(pointerInWasm + 64);
	}
	WasmP & request_process() {
		return *(WasmP *)(pointerInWasm + 72);
	}
	WasmP & request_callback() {
		return *(WasmP *)(pointerInWasm + 80);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_t>(ScopedThread &scoped, const clap_host_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_t>(const clap_host_t *native);

using wclap_event_header = clap_event_header_t;

using wclap_event_note = clap_event_note_t;

using wclap_event_note_expression = clap_event_note_expression_t;

struct wclap_event_param_value {
	wclap_event_param_value(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 48;
	
	operator bool() const {
		return pointerInWasm;
	}

	clap_event_header_t & header() {
		return *(clap_event_header_t *)pointerInWasm;
	}
	uint32_t & param_id() {
		return *(uint32_t *)(pointerInWasm + 16);
	}
	WasmP & cookie() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	int32_t & note_id() {
		return *(int32_t *)(pointerInWasm + 28);
	}
	int16_t & port_index() {
		return *(int16_t *)(pointerInWasm + 32);
	}
	int16_t & channel() {
		return *(int16_t *)(pointerInWasm + 34);
	}
	int16_t & key() {
		return *(int16_t *)(pointerInWasm + 36);
	}
	double & value() {
		return *(double *)(pointerInWasm + 40);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_event_param_value_t>(ScopedThread &scoped, WasmP wasmP, const clap_event_param_value_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_event_param_value_t *&constNativeP) {
	auto wasm = scoped.view<wclap_event_param_value>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_event_param_value_t>();
	constNativeP = native;
	native->header = wasm.header();
	native->param_id = wasm.param_id();
	wasmToNative(scoped, wasm.cookie(), native->cookie);
	native->note_id = wasm.note_id();
	native->port_index = wasm.port_index();
	native->channel = wasm.channel();
	native->key = wasm.key();
	native->value = wasm.value();
}

template<>
void nativeToWasm<const clap_event_param_value_t>(ScopedThread &scoped, const clap_event_param_value_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_event_param_value_t>(const clap_event_param_value_t *native);

struct wclap_event_param_mod {
	wclap_event_param_mod(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 48;
	
	operator bool() const {
		return pointerInWasm;
	}

	clap_event_header_t & header() {
		return *(clap_event_header_t *)pointerInWasm;
	}
	uint32_t & param_id() {
		return *(uint32_t *)(pointerInWasm + 16);
	}
	WasmP & cookie() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	int32_t & note_id() {
		return *(int32_t *)(pointerInWasm + 28);
	}
	int16_t & port_index() {
		return *(int16_t *)(pointerInWasm + 32);
	}
	int16_t & channel() {
		return *(int16_t *)(pointerInWasm + 34);
	}
	int16_t & key() {
		return *(int16_t *)(pointerInWasm + 36);
	}
	double & amount() {
		return *(double *)(pointerInWasm + 40);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_event_param_mod_t>(ScopedThread &scoped, WasmP wasmP, const clap_event_param_mod_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_event_param_mod_t *&constNativeP) {
	auto wasm = scoped.view<wclap_event_param_mod>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_event_param_mod_t>();
	constNativeP = native;
	native->header = wasm.header();
	native->param_id = wasm.param_id();
	wasmToNative(scoped, wasm.cookie(), native->cookie);
	native->note_id = wasm.note_id();
	native->port_index = wasm.port_index();
	native->channel = wasm.channel();
	native->key = wasm.key();
	native->amount = wasm.amount();
}

template<>
void nativeToWasm<const clap_event_param_mod_t>(ScopedThread &scoped, const clap_event_param_mod_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_event_param_mod_t>(const clap_event_param_mod_t *native);

using wclap_event_param_gesture = clap_event_param_gesture_t;

using wclap_event_transport = clap_event_transport_t;

using wclap_event_midi = clap_event_midi_t;

struct wclap_event_midi_sysex {
	wclap_event_midi_sysex(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 32;
	
	operator bool() const {
		return pointerInWasm;
	}

	clap_event_header_t & header() {
		return *(clap_event_header_t *)pointerInWasm;
	}
	uint16_t & port_index() {
		return *(uint16_t *)(pointerInWasm + 16);
	}
	WasmP & buffer() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	uint32_t & size() {
		return *(uint32_t *)(pointerInWasm + 28);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_event_midi_sysex_t>(ScopedThread &scoped, WasmP wasmP, const clap_event_midi_sysex_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_event_midi_sysex_t *&constNativeP) {
	auto wasm = scoped.view<wclap_event_midi_sysex>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_event_midi_sysex_t>();
	constNativeP = native;
	native->header = wasm.header();
	native->port_index = wasm.port_index();
	wasmToNative(scoped, wasm.buffer(), native->buffer);
	native->size = wasm.size();
}

template<>
void nativeToWasm<const clap_event_midi_sysex_t>(ScopedThread &scoped, const clap_event_midi_sysex_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_event_midi_sysex_t>(const clap_event_midi_sysex_t *native);

using wclap_event_midi2 = clap_event_midi2_t;

struct wclap_input_events {
	wclap_input_events(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 24;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & ctx() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & size() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & get() {
		return *(WasmP *)(pointerInWasm + 16);
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_size(const struct clap_input_events *list) {
		auto &context = getNativeProxyContext(list);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_input_events>(context.wasmMap.input_events).size();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.input_events);
		return wasmResult;
	} 
	template<bool realtime=false>
	static const clap_event_header_t * nativeProxy_get(const struct clap_input_events *list, uint32_t index) {
		auto &context = getNativeProxyContext(list);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_input_events>(context.wasmMap.input_events).get();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.input_events, index);

		auto resetN = scoped.arenas.scopedNativeReset();
		const clap_event_header_t *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_input_events_t>(ScopedThread &scoped, WasmP wasmP, const clap_input_events_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_input_events_t *&constNativeP) {
	auto wasm = scoped.view<wclap_input_events>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_input_events_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.ctx(), native->ctx);
	native->size = wclap_input_events::nativeProxy_size<false>;
	native->get = wclap_input_events::nativeProxy_get<false>;
}

template<>
void nativeToWasm<const clap_input_events_t>(ScopedThread &scoped, const clap_input_events_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_input_events_t>(const clap_input_events_t *native);

struct wclap_output_events {
	wclap_output_events(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & ctx() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & try_push() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static bool nativeProxy_try_push(const struct clap_output_events *list, const clap_event_header_t *event) {
		auto &context = getNativeProxyContext(list);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_output_events>(context.wasmMap.output_events).try_push();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_event;
		nativeToWasm(scoped, event, wasm_event);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.output_events, wasm_event);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_output_events_t>(ScopedThread &scoped, WasmP wasmP, const clap_output_events_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_output_events_t *&constNativeP) {
	auto wasm = scoped.view<wclap_output_events>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_output_events_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.ctx(), native->ctx);
	native->try_push = wclap_output_events::nativeProxy_try_push<false>;
}

template<>
void nativeToWasm<const clap_output_events_t>(ScopedThread &scoped, const clap_output_events_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_output_events_t>(const clap_output_events_t *native);

struct wclap_audio_buffer {
	wclap_audio_buffer(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 32;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & data32() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & data64() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	uint32_t & channel_count() {
		return *(uint32_t *)(pointerInWasm + 16);
	}
	uint32_t & latency() {
		return *(uint32_t *)(pointerInWasm + 20);
	}
	uint64_t & constant_mask() {
		return *(uint64_t *)(pointerInWasm + 24);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_audio_buffer_t>(ScopedThread &scoped, WasmP wasmP, const clap_audio_buffer_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_audio_buffer_t *&constNativeP) {
	auto wasm = scoped.view<wclap_audio_buffer>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_audio_buffer_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.data32(), native->data32);
	wasmToNative(scoped, wasm.data64(), native->data64);
	native->channel_count = wasm.channel_count();
	native->latency = wasm.latency();
	native->constant_mask = wasm.constant_mask();
}

template<>
void nativeToWasm<const clap_audio_buffer_t>(ScopedThread &scoped, const clap_audio_buffer_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_audio_buffer_t>(const clap_audio_buffer_t *native);

struct wclap_process {
	wclap_process(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 64;
	
	operator bool() const {
		return pointerInWasm;
	}

	int64_t & steady_time() {
		return *(int64_t *)pointerInWasm;
	}
	uint32_t & frames_count() {
		return *(uint32_t *)(pointerInWasm + 8);
	}
	WasmP & transport() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & audio_inputs() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & audio_outputs() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	uint32_t & audio_inputs_count() {
		return *(uint32_t *)(pointerInWasm + 36);
	}
	uint32_t & audio_outputs_count() {
		return *(uint32_t *)(pointerInWasm + 40);
	}
	WasmP & in_events() {
		return *(WasmP *)(pointerInWasm + 48);
	}
	WasmP & out_events() {
		return *(WasmP *)(pointerInWasm + 56);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_process_t>(ScopedThread &scoped, WasmP wasmP, const clap_process_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_process_t *&constNativeP) {
	auto wasm = scoped.view<wclap_process>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_process_t>();
	constNativeP = native;
	native->steady_time = wasm.steady_time();
	native->frames_count = wasm.frames_count();
	wasmToNative(scoped, wasm.transport(), native->transport);
	wasmToNative(scoped, wasm.audio_inputs(), native->audio_inputs);
	wasmToNative(scoped, wasm.audio_outputs(), native->audio_outputs);
	native->audio_inputs_count = wasm.audio_inputs_count();
	native->audio_outputs_count = wasm.audio_outputs_count();
	wasmToNative(scoped, wasm.in_events(), native->in_events);
	wasmToNative(scoped, wasm.out_events(), native->out_events);
}

template<>
void nativeToWasm<const clap_process_t>(ScopedThread &scoped, const clap_process_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_process_t>(const clap_process_t *native);

struct wclap_plugin_descriptor {
	wclap_plugin_descriptor(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 88;
	
	operator bool() const {
		return pointerInWasm;
	}

	clap_version_t & clap_version() {
		return *(clap_version_t *)pointerInWasm;
	}
	WasmP & id() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & name() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & vendor() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & url() {
		return *(WasmP *)(pointerInWasm + 40);
	}
	WasmP & manual_url() {
		return *(WasmP *)(pointerInWasm + 48);
	}
	WasmP & support_url() {
		return *(WasmP *)(pointerInWasm + 56);
	}
	WasmP & version() {
		return *(WasmP *)(pointerInWasm + 64);
	}
	WasmP & description() {
		return *(WasmP *)(pointerInWasm + 72);
	}
	WasmP & features() {
		return *(WasmP *)(pointerInWasm + 80);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_descriptor_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_descriptor_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_descriptor_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_descriptor>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_descriptor_t>();
	constNativeP = native;
	native->clap_version = wasm.clap_version();
	wasmToNative(scoped, wasm.id(), native->id);
	wasmToNative(scoped, wasm.name(), native->name);
	wasmToNative(scoped, wasm.vendor(), native->vendor);
	wasmToNative(scoped, wasm.url(), native->url);
	wasmToNative(scoped, wasm.manual_url(), native->manual_url);
	wasmToNative(scoped, wasm.support_url(), native->support_url);
	wasmToNative(scoped, wasm.version(), native->version);
	wasmToNative(scoped, wasm.description(), native->description);
	wasmToNative(scoped, wasm.features(), native->features);
}

template<>
void * & nativeProxyContextPointer<clap_plugin_descriptor_t>(const clap_plugin_descriptor_t *native);

struct wclap_plugin {
	wclap_plugin(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 96;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & desc() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & plugin_data() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & init() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & destroy() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & activate() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & deactivate() {
		return *(WasmP *)(pointerInWasm + 40);
	}
	WasmP & start_processing() {
		return *(WasmP *)(pointerInWasm + 48);
	}
	WasmP & stop_processing() {
		return *(WasmP *)(pointerInWasm + 56);
	}
	WasmP & reset() {
		return *(WasmP *)(pointerInWasm + 64);
	}
	WasmP & process() {
		return *(WasmP *)(pointerInWasm + 72);
	}
	WasmP & get_extension() {
		return *(WasmP *)(pointerInWasm + 80);
	}
	WasmP & on_main_thread() {
		return *(WasmP *)(pointerInWasm + 88);
	}

	template<bool realtime=false>
	static bool nativeProxy_init(const struct clap_plugin *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).init();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_destroy(const struct clap_plugin *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).destroy();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin);
	}   
	template<bool realtime=false>
	static bool nativeProxy_activate(const struct clap_plugin *plugin, double sample_rate, uint32_t min_frames_count, uint32_t max_frames_count) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).activate();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, sample_rate, min_frames_count, max_frames_count);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_deactivate(const struct clap_plugin *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).deactivate();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin);
	}
	template<bool realtime=false>
	static bool nativeProxy_start_processing(const struct clap_plugin *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).start_processing();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_stop_processing(const struct clap_plugin *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).stop_processing();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin);
	}
	template<bool realtime=false>
	static void nativeProxy_reset(const struct clap_plugin *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).reset();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin);
	}
	template<bool realtime=false>
	static clap_process_status nativeProxy_process(const struct clap_plugin *plugin, const clap_process_t *process) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).process();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_process;
		nativeToWasm(scoped, process, wasm_process);
		int32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_process);
		return wasmResult;
	}
	template<bool realtime=false>
	static const void * nativeProxy_get_extension(const struct clap_plugin *plugin, const char *id) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).get_extension();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_id;
		nativeToWasm(scoped, id, wasm_id);
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.plugin, wasm_id);

		auto resetN = scoped.arenas.scopedNativeReset();
		const void *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
	template<bool realtime=false>
	static void nativeProxy_on_main_thread(const struct clap_plugin *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin>(context.wasmMap.plugin).on_main_thread();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.desc(), native->desc);
	wasmToNative(scoped, wasm.plugin_data(), native->plugin_data);
	native->init = wclap_plugin::nativeProxy_init<false>;
	native->destroy = wclap_plugin::nativeProxy_destroy<false>;
	native->activate = wclap_plugin::nativeProxy_activate<false>;
	native->deactivate = wclap_plugin::nativeProxy_deactivate<false>;
	native->start_processing = wclap_plugin::nativeProxy_start_processing<false>;
	native->stop_processing = wclap_plugin::nativeProxy_stop_processing<false>;
	native->reset = wclap_plugin::nativeProxy_reset<false>;
	native->process = wclap_plugin::nativeProxy_process<false>;
	native->get_extension = wclap_plugin::nativeProxy_get_extension<false>;
	native->on_main_thread = wclap_plugin::nativeProxy_on_main_thread<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_t>(const clap_plugin_t *native);

struct wclap_plugin_factory {
	wclap_plugin_factory(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 24;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & get_plugin_count() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get_plugin_descriptor() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & create_plugin() {
		return *(WasmP *)(pointerInWasm + 16);
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_get_plugin_count(const struct clap_plugin_factory *factory) {
		auto &context = getNativeProxyContext(factory);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_factory>(context.wasmMap.plugin_factory).get_plugin_count();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin_factory);
		return wasmResult;
	} 
	template<bool realtime=false>
	static const clap_plugin_descriptor_t * nativeProxy_get_plugin_descriptor(const struct clap_plugin_factory *factory, uint32_t index) {
		auto &context = getNativeProxyContext(factory);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_factory>(context.wasmMap.plugin_factory).get_plugin_descriptor();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.plugin_factory, index);

		auto resetN = scoped.arenas.scopedNativeReset();
		const clap_plugin_descriptor_t *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
	template<bool realtime=false>
	static const clap_plugin_t * nativeProxy_create_plugin(const struct clap_plugin_factory *factory, const clap_host_t *host, const char *plugin_id) {
		auto &context = getNativeProxyContext(factory);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_factory>(context.wasmMap.plugin_factory).create_plugin();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_host;
		nativeToWasm(scoped, host, wasm_host);
		WasmP wasm_plugin_id;
		nativeToWasm(scoped, plugin_id, wasm_plugin_id);
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.plugin_factory, wasm_host, wasm_plugin_id);

		auto resetN = scoped.arenas.scopedNativeReset();
		const clap_plugin_t *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_factory_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_factory_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_factory_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_factory>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_factory_t>();
	constNativeP = native;
	native->get_plugin_count = wclap_plugin_factory::nativeProxy_get_plugin_count<false>;
	native->get_plugin_descriptor = wclap_plugin_factory::nativeProxy_get_plugin_descriptor<false>;
	native->create_plugin = wclap_plugin_factory::nativeProxy_create_plugin<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_factory_t>(const clap_plugin_factory_t *native);

struct wclap_universal_plugin_id {
	wclap_universal_plugin_id(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & abi() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & id() {
		return *(WasmP *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_universal_plugin_id_t>(ScopedThread &scoped, WasmP wasmP, const clap_universal_plugin_id_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_universal_plugin_id_t *&constNativeP) {
	auto wasm = scoped.view<wclap_universal_plugin_id>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_universal_plugin_id_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.abi(), native->abi);
	wasmToNative(scoped, wasm.id(), native->id);
}

template<>
void nativeToWasm<const clap_universal_plugin_id_t>(ScopedThread &scoped, const clap_universal_plugin_id_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_universal_plugin_id_t>(const clap_universal_plugin_id_t *native);

struct wclap_preset_discovery_metadata_receiver {
	wclap_preset_discovery_metadata_receiver(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 88;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & receiver_data() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & on_error() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & begin_preset() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & add_plugin_id() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & set_soundpack_id() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & set_flags() {
		return *(WasmP *)(pointerInWasm + 40);
	}
	WasmP & add_creator() {
		return *(WasmP *)(pointerInWasm + 48);
	}
	WasmP & set_description() {
		return *(WasmP *)(pointerInWasm + 56);
	}
	WasmP & set_timestamps() {
		return *(WasmP *)(pointerInWasm + 64);
	}
	WasmP & add_feature() {
		return *(WasmP *)(pointerInWasm + 72);
	}
	WasmP & add_extra_info() {
		return *(WasmP *)(pointerInWasm + 80);
	}
 
	template<bool realtime=false>
	static void nativeProxy_on_error(const struct clap_preset_discovery_metadata_receiver *receiver, int32_t os_error, const char *error_message) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).on_error();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_error_message;
		nativeToWasm(scoped, error_message, wasm_error_message);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, os_error, wasm_error_message);
	}
	template<bool realtime=false>
	static bool nativeProxy_begin_preset(const struct clap_preset_discovery_metadata_receiver *receiver, const char *name, const char *load_key) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).begin_preset();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_name;
		nativeToWasm(scoped, name, wasm_name);
		WasmP wasm_load_key;
		nativeToWasm(scoped, load_key, wasm_load_key);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, wasm_name, wasm_load_key);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_add_plugin_id(const struct clap_preset_discovery_metadata_receiver *receiver, const clap_universal_plugin_id_t *plugin_id) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).add_plugin_id();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_plugin_id;
		nativeToWasm(scoped, plugin_id, wasm_plugin_id);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, wasm_plugin_id);
	}
	template<bool realtime=false>
	static void nativeProxy_set_soundpack_id(const struct clap_preset_discovery_metadata_receiver *receiver, const char *soundpack_id) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).set_soundpack_id();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_soundpack_id;
		nativeToWasm(scoped, soundpack_id, wasm_soundpack_id);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, wasm_soundpack_id);
	} 
	template<bool realtime=false>
	static void nativeProxy_set_flags(const struct clap_preset_discovery_metadata_receiver *receiver, uint32_t flags) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).set_flags();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, flags);
	}
	template<bool realtime=false>
	static void nativeProxy_add_creator(const struct clap_preset_discovery_metadata_receiver *receiver, const char *creator) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).add_creator();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_creator;
		nativeToWasm(scoped, creator, wasm_creator);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, wasm_creator);
	}
	template<bool realtime=false>
	static void nativeProxy_set_description(const struct clap_preset_discovery_metadata_receiver *receiver, const char *description) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).set_description();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_description;
		nativeToWasm(scoped, description, wasm_description);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, wasm_description);
	}  
	template<bool realtime=false>
	static void nativeProxy_set_timestamps(const struct clap_preset_discovery_metadata_receiver *receiver, clap_timestamp creation_time, clap_timestamp modification_time) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).set_timestamps();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, creation_time, modification_time);
	}
	template<bool realtime=false>
	static void nativeProxy_add_feature(const struct clap_preset_discovery_metadata_receiver *receiver, const char *feature) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).add_feature();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_feature;
		nativeToWasm(scoped, feature, wasm_feature);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, wasm_feature);
	}
	template<bool realtime=false>
	static void nativeProxy_add_extra_info(const struct clap_preset_discovery_metadata_receiver *receiver, const char *key, const char *value) {
		auto &context = getNativeProxyContext(receiver);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_metadata_receiver>(context.wasmMap.preset_discovery_metadata_receiver).add_extra_info();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_key;
		nativeToWasm(scoped, key, wasm_key);
		WasmP wasm_value;
		nativeToWasm(scoped, value, wasm_value);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_metadata_receiver, wasm_key, wasm_value);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_preset_discovery_metadata_receiver_t>(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_metadata_receiver_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_metadata_receiver_t *&constNativeP) {
	auto wasm = scoped.view<wclap_preset_discovery_metadata_receiver>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_preset_discovery_metadata_receiver_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.receiver_data(), native->receiver_data);
	native->on_error = wclap_preset_discovery_metadata_receiver::nativeProxy_on_error<false>;
	native->begin_preset = wclap_preset_discovery_metadata_receiver::nativeProxy_begin_preset<false>;
	native->add_plugin_id = wclap_preset_discovery_metadata_receiver::nativeProxy_add_plugin_id<false>;
	native->set_soundpack_id = wclap_preset_discovery_metadata_receiver::nativeProxy_set_soundpack_id<false>;
	native->set_flags = wclap_preset_discovery_metadata_receiver::nativeProxy_set_flags<false>;
	native->add_creator = wclap_preset_discovery_metadata_receiver::nativeProxy_add_creator<false>;
	native->set_description = wclap_preset_discovery_metadata_receiver::nativeProxy_set_description<false>;
	native->set_timestamps = wclap_preset_discovery_metadata_receiver::nativeProxy_set_timestamps<false>;
	native->add_feature = wclap_preset_discovery_metadata_receiver::nativeProxy_add_feature<false>;
	native->add_extra_info = wclap_preset_discovery_metadata_receiver::nativeProxy_add_extra_info<false>;
}

template<>
void nativeToWasm<const clap_preset_discovery_metadata_receiver_t>(ScopedThread &scoped, const clap_preset_discovery_metadata_receiver_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_preset_discovery_metadata_receiver_t>(const clap_preset_discovery_metadata_receiver_t *native);

struct wclap_preset_discovery_filetype {
	wclap_preset_discovery_filetype(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 24;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & name() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & description() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & file_extension() {
		return *(WasmP *)(pointerInWasm + 16);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_preset_discovery_filetype_t>(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_filetype_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_filetype_t *&constNativeP) {
	auto wasm = scoped.view<wclap_preset_discovery_filetype>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_preset_discovery_filetype_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.name(), native->name);
	wasmToNative(scoped, wasm.description(), native->description);
	wasmToNative(scoped, wasm.file_extension(), native->file_extension);
}

template<>
void nativeToWasm<const clap_preset_discovery_filetype_t>(ScopedThread &scoped, const clap_preset_discovery_filetype_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_preset_discovery_filetype_t>(const clap_preset_discovery_filetype_t *native);

struct wclap_preset_discovery_location {
	wclap_preset_discovery_location(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 24;
	
	operator bool() const {
		return pointerInWasm;
	}

	uint32_t & flags() {
		return *(uint32_t *)pointerInWasm;
	}
	WasmP & name() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	uint32_t & kind() {
		return *(uint32_t *)(pointerInWasm + 12);
	}
	WasmP & location() {
		return *(WasmP *)(pointerInWasm + 16);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_preset_discovery_location_t>(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_location_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_location_t *&constNativeP) {
	auto wasm = scoped.view<wclap_preset_discovery_location>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_preset_discovery_location_t>();
	constNativeP = native;
	native->flags = wasm.flags();
	wasmToNative(scoped, wasm.name(), native->name);
	native->kind = wasm.kind();
	wasmToNative(scoped, wasm.location(), native->location);
}

template<>
void nativeToWasm<const clap_preset_discovery_location_t>(ScopedThread &scoped, const clap_preset_discovery_location_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_preset_discovery_location_t>(const clap_preset_discovery_location_t *native);

struct wclap_preset_discovery_soundpack {
	wclap_preset_discovery_soundpack(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 64;
	
	operator bool() const {
		return pointerInWasm;
	}

	uint32_t & flags() {
		return *(uint32_t *)pointerInWasm;
	}
	WasmP & id() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & name() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & description() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & homepage_url() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & vendor() {
		return *(WasmP *)(pointerInWasm + 40);
	}
	WasmP & image_path() {
		return *(WasmP *)(pointerInWasm + 48);
	}
	uint64_t & release_timestamp() {
		return *(uint64_t *)(pointerInWasm + 56);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_preset_discovery_soundpack_t>(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_soundpack_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_soundpack_t *&constNativeP) {
	auto wasm = scoped.view<wclap_preset_discovery_soundpack>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_preset_discovery_soundpack_t>();
	constNativeP = native;
	native->flags = wasm.flags();
	wasmToNative(scoped, wasm.id(), native->id);
	wasmToNative(scoped, wasm.name(), native->name);
	wasmToNative(scoped, wasm.description(), native->description);
	wasmToNative(scoped, wasm.homepage_url(), native->homepage_url);
	wasmToNative(scoped, wasm.vendor(), native->vendor);
	wasmToNative(scoped, wasm.image_path(), native->image_path);
	native->release_timestamp = wasm.release_timestamp();
}

template<>
void nativeToWasm<const clap_preset_discovery_soundpack_t>(ScopedThread &scoped, const clap_preset_discovery_soundpack_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_preset_discovery_soundpack_t>(const clap_preset_discovery_soundpack_t *native);

struct wclap_preset_discovery_provider_descriptor {
	wclap_preset_discovery_provider_descriptor(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 40;
	
	operator bool() const {
		return pointerInWasm;
	}

	clap_version_t & clap_version() {
		return *(clap_version_t *)pointerInWasm;
	}
	WasmP & id() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & name() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & vendor() {
		return *(WasmP *)(pointerInWasm + 32);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_preset_discovery_provider_descriptor_t>(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_provider_descriptor_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_provider_descriptor_t *&constNativeP) {
	auto wasm = scoped.view<wclap_preset_discovery_provider_descriptor>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_preset_discovery_provider_descriptor_t>();
	constNativeP = native;
	native->clap_version = wasm.clap_version();
	wasmToNative(scoped, wasm.id(), native->id);
	wasmToNative(scoped, wasm.name(), native->name);
	wasmToNative(scoped, wasm.vendor(), native->vendor);
}

template<>
void nativeToWasm<const clap_preset_discovery_provider_descriptor_t>(ScopedThread &scoped, const clap_preset_discovery_provider_descriptor_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_preset_discovery_provider_descriptor_t>(const clap_preset_discovery_provider_descriptor_t *native);

struct wclap_preset_discovery_provider {
	wclap_preset_discovery_provider(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 48;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & desc() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & provider_data() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & init() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & destroy() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & get_metadata() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & get_extension() {
		return *(WasmP *)(pointerInWasm + 40);
	}

	template<bool realtime=false>
	static bool nativeProxy_init(const struct clap_preset_discovery_provider *provider) {
		auto &context = getNativeProxyContext(provider);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_provider>(context.wasmMap.preset_discovery_provider).init();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.preset_discovery_provider);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_destroy(const struct clap_preset_discovery_provider *provider) {
		auto &context = getNativeProxyContext(provider);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_provider>(context.wasmMap.preset_discovery_provider).destroy();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.preset_discovery_provider);
	} 
	template<bool realtime=false>
	static bool nativeProxy_get_metadata(const struct clap_preset_discovery_provider *provider, uint32_t location_kind, const char *location, const clap_preset_discovery_metadata_receiver_t *metadata_receiver) {
		auto &context = getNativeProxyContext(provider);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_provider>(context.wasmMap.preset_discovery_provider).get_metadata();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_location;
		nativeToWasm(scoped, location, wasm_location);
		WasmP wasm_metadata_receiver;
		nativeToWasm(scoped, metadata_receiver, wasm_metadata_receiver);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.preset_discovery_provider, location_kind, wasm_location, wasm_metadata_receiver);
		return wasmResult;
	}
	template<bool realtime=false>
	static const void * nativeProxy_get_extension(const struct clap_preset_discovery_provider *provider, const char *extension_id) {
		auto &context = getNativeProxyContext(provider);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_provider>(context.wasmMap.preset_discovery_provider).get_extension();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_extension_id;
		nativeToWasm(scoped, extension_id, wasm_extension_id);
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.preset_discovery_provider, wasm_extension_id);

		auto resetN = scoped.arenas.scopedNativeReset();
		const void *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_preset_discovery_provider_t>(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_provider_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_provider_t *&constNativeP) {
	auto wasm = scoped.view<wclap_preset_discovery_provider>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_preset_discovery_provider_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.desc(), native->desc);
	wasmToNative(scoped, wasm.provider_data(), native->provider_data);
	native->init = wclap_preset_discovery_provider::nativeProxy_init<false>;
	native->destroy = wclap_preset_discovery_provider::nativeProxy_destroy<false>;
	native->get_metadata = wclap_preset_discovery_provider::nativeProxy_get_metadata<false>;
	native->get_extension = wclap_preset_discovery_provider::nativeProxy_get_extension<false>;
}

template<>
void nativeToWasm<const clap_preset_discovery_provider_t>(ScopedThread &scoped, const clap_preset_discovery_provider_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_preset_discovery_provider_t>(const clap_preset_discovery_provider_t *native);

struct wclap_preset_discovery_indexer {
	wclap_preset_discovery_indexer(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 88;
	
	operator bool() const {
		return pointerInWasm;
	}

	clap_version_t & clap_version() {
		return *(clap_version_t *)pointerInWasm;
	}
	WasmP & name() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & vendor() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & url() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & version() {
		return *(WasmP *)(pointerInWasm + 40);
	}
	WasmP & indexer_data() {
		return *(WasmP *)(pointerInWasm + 48);
	}
	WasmP & declare_filetype() {
		return *(WasmP *)(pointerInWasm + 56);
	}
	WasmP & declare_location() {
		return *(WasmP *)(pointerInWasm + 64);
	}
	WasmP & declare_soundpack() {
		return *(WasmP *)(pointerInWasm + 72);
	}
	WasmP & get_extension() {
		return *(WasmP *)(pointerInWasm + 80);
	}

	template<bool realtime=false>
	static bool nativeProxy_declare_filetype(const struct clap_preset_discovery_indexer *indexer, const clap_preset_discovery_filetype_t *filetype) {
		auto &context = getNativeProxyContext(indexer);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_indexer>(context.wasmMap.preset_discovery_indexer).declare_filetype();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_filetype;
		nativeToWasm(scoped, filetype, wasm_filetype);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.preset_discovery_indexer, wasm_filetype);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_declare_location(const struct clap_preset_discovery_indexer *indexer, const clap_preset_discovery_location_t *location) {
		auto &context = getNativeProxyContext(indexer);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_indexer>(context.wasmMap.preset_discovery_indexer).declare_location();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_location;
		nativeToWasm(scoped, location, wasm_location);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.preset_discovery_indexer, wasm_location);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_declare_soundpack(const struct clap_preset_discovery_indexer *indexer, const clap_preset_discovery_soundpack_t *soundpack) {
		auto &context = getNativeProxyContext(indexer);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_indexer>(context.wasmMap.preset_discovery_indexer).declare_soundpack();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_soundpack;
		nativeToWasm(scoped, soundpack, wasm_soundpack);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.preset_discovery_indexer, wasm_soundpack);
		return wasmResult;
	}
	template<bool realtime=false>
	static const void * nativeProxy_get_extension(const struct clap_preset_discovery_indexer *indexer, const char *extension_id) {
		auto &context = getNativeProxyContext(indexer);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_indexer>(context.wasmMap.preset_discovery_indexer).get_extension();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_extension_id;
		nativeToWasm(scoped, extension_id, wasm_extension_id);
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.preset_discovery_indexer, wasm_extension_id);

		auto resetN = scoped.arenas.scopedNativeReset();
		const void *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_preset_discovery_indexer_t>(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_indexer_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_indexer_t *&constNativeP) {
	auto wasm = scoped.view<wclap_preset_discovery_indexer>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_preset_discovery_indexer_t>();
	constNativeP = native;
	native->clap_version = wasm.clap_version();
	wasmToNative(scoped, wasm.name(), native->name);
	wasmToNative(scoped, wasm.vendor(), native->vendor);
	wasmToNative(scoped, wasm.url(), native->url);
	wasmToNative(scoped, wasm.version(), native->version);
	wasmToNative(scoped, wasm.indexer_data(), native->indexer_data);
	native->declare_filetype = wclap_preset_discovery_indexer::nativeProxy_declare_filetype<false>;
	native->declare_location = wclap_preset_discovery_indexer::nativeProxy_declare_location<false>;
	native->declare_soundpack = wclap_preset_discovery_indexer::nativeProxy_declare_soundpack<false>;
	native->get_extension = wclap_preset_discovery_indexer::nativeProxy_get_extension<false>;
}

template<>
void nativeToWasm<const clap_preset_discovery_indexer_t>(ScopedThread &scoped, const clap_preset_discovery_indexer_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_preset_discovery_indexer_t>(const clap_preset_discovery_indexer_t *native);

struct wclap_preset_discovery_factory {
	wclap_preset_discovery_factory(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 24;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & count() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get_descriptor() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & create() {
		return *(WasmP *)(pointerInWasm + 16);
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_count(const struct clap_preset_discovery_factory *factory) {
		auto &context = getNativeProxyContext(factory);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_factory>(context.wasmMap.preset_discovery_factory).count();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.preset_discovery_factory);
		return wasmResult;
	} 
	template<bool realtime=false>
	static const clap_preset_discovery_provider_descriptor_t * nativeProxy_get_descriptor(const struct clap_preset_discovery_factory *factory, uint32_t index) {
		auto &context = getNativeProxyContext(factory);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_factory>(context.wasmMap.preset_discovery_factory).get_descriptor();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.preset_discovery_factory, index);

		auto resetN = scoped.arenas.scopedNativeReset();
		const clap_preset_discovery_provider_descriptor_t *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
	template<bool realtime=false>
	static const clap_preset_discovery_provider_t * nativeProxy_create(const struct clap_preset_discovery_factory *factory, const clap_preset_discovery_indexer_t *indexer, const char *provider_id) {
		auto &context = getNativeProxyContext(factory);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_preset_discovery_factory>(context.wasmMap.preset_discovery_factory).create();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_indexer;
		nativeToWasm(scoped, indexer, wasm_indexer);
		WasmP wasm_provider_id;
		nativeToWasm(scoped, provider_id, wasm_provider_id);
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.preset_discovery_factory, wasm_indexer, wasm_provider_id);

		auto resetN = scoped.arenas.scopedNativeReset();
		const clap_preset_discovery_provider_t *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_preset_discovery_factory_t>(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_factory_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_preset_discovery_factory_t *&constNativeP) {
	auto wasm = scoped.view<wclap_preset_discovery_factory>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_preset_discovery_factory_t>();
	constNativeP = native;
	native->count = wclap_preset_discovery_factory::nativeProxy_count<false>;
	native->get_descriptor = wclap_preset_discovery_factory::nativeProxy_get_descriptor<false>;
	native->create = wclap_preset_discovery_factory::nativeProxy_create<false>;
}

template<>
void nativeToWasm<const clap_preset_discovery_factory_t>(ScopedThread &scoped, const clap_preset_discovery_factory_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_preset_discovery_factory_t>(const clap_preset_discovery_factory_t *native);

struct wclap_plugin_entry {
	wclap_plugin_entry(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 40;
	
	operator bool() const {
		return pointerInWasm;
	}

	clap_version_t & clap_version() {
		return *(clap_version_t *)pointerInWasm;
	}
	WasmP & init() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & deinit() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & get_factory() {
		return *(WasmP *)(pointerInWasm + 32);
	}

	template<bool realtime=false>
	static bool nativeProxy_init(const char *plugin_path) {
		auto &context = getNativeProxyContext(plugin_path);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_entry>(context.wasmMap.plugin_entry).init();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.char);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_deinit() {
		auto &context = getNativeProxyContext((clap_plugin_entry_t *)nullptr);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_entry>(context.wasmMap.plugin_entry).deinit();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.unknown);
	}
	template<bool realtime=false>
	static const void * nativeProxy_get_factory(const char *factory_id) {
		auto &context = getNativeProxyContext(factory_id);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_entry>(context.wasmMap.plugin_entry).get_factory();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasmResult = scoped.thread.callWasm_P(wasmFn, context.wasmMap.char);

		auto resetN = scoped.arenas.scopedNativeReset();
		const void *nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_entry_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_entry_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_entry_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_entry>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_entry_t>();
	constNativeP = native;
	native->clap_version = wasm.clap_version();
	native->init = wclap_plugin_entry::nativeProxy_init<false>;
	native->deinit = wclap_plugin_entry::nativeProxy_deinit<false>;
	native->get_factory = wclap_plugin_entry::nativeProxy_get_factory<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_entry_t>(const clap_plugin_entry_t *native);

using wclap_color = clap_color_t;

struct wclap_istream {
	wclap_istream(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & ctx() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & read() {
		return *(WasmP *)(pointerInWasm + 8);
	}
 
	template<bool realtime=false>
	static int64_t nativeProxy_read(const struct clap_istream *stream, void *buffer, uint64_t size) {
		auto &context = getNativeProxyContext(stream);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_istream>(context.wasmMap.istream).read();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_buffer;
		nativeToWasm(scoped, buffer, wasm_buffer);
		int64_t wasmResult = scoped.thread.callWasm_L(wasmFn, context.wasmMap.istream, wasm_buffer, size);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_istream_t>(ScopedThread &scoped, WasmP wasmP, const clap_istream_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_istream_t *&constNativeP) {
	auto wasm = scoped.view<wclap_istream>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_istream_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.ctx(), native->ctx);
	native->read = wclap_istream::nativeProxy_read<false>;
}

template<>
void nativeToWasm<const clap_istream_t>(ScopedThread &scoped, const clap_istream_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_istream_t>(const clap_istream_t *native);

struct wclap_ostream {
	wclap_ostream(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & ctx() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & write() {
		return *(WasmP *)(pointerInWasm + 8);
	}
 
	template<bool realtime=false>
	static int64_t nativeProxy_write(const struct clap_ostream *stream, const void *buffer, uint64_t size) {
		auto &context = getNativeProxyContext(stream);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_ostream>(context.wasmMap.ostream).write();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_buffer;
		nativeToWasm(scoped, buffer, wasm_buffer);
		int64_t wasmResult = scoped.thread.callWasm_L(wasmFn, context.wasmMap.ostream, wasm_buffer, size);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_ostream_t>(ScopedThread &scoped, WasmP wasmP, const clap_ostream_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_ostream_t *&constNativeP) {
	auto wasm = scoped.view<wclap_ostream>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_ostream_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.ctx(), native->ctx);
	native->write = wclap_ostream::nativeProxy_write<false>;
}

template<>
void nativeToWasm<const clap_ostream_t>(ScopedThread &scoped, const clap_ostream_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_ostream_t>(const clap_ostream_t *native);

using wclap_ambisonic_config = clap_ambisonic_config_t;

struct wclap_plugin_ambisonic {
	wclap_plugin_ambisonic(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & is_config_supported() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get_config() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static bool nativeProxy_is_config_supported(const clap_plugin_t *plugin, const clap_ambisonic_config_t *config) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_ambisonic>(context.wasmMap.plugin_ambisonic).is_config_supported();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_config;
		nativeToWasm(scoped, config, wasm_config);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_config);
		return wasmResult;
	}  
	template<bool realtime=false>
	static bool nativeProxy_get_config(const clap_plugin_t *plugin, bool is_input, uint32_t port_index, clap_ambisonic_config_t *config) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_ambisonic>(context.wasmMap.plugin_ambisonic).get_config();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_config;
		nativeToWasm(scoped, config, wasm_config);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, is_input, port_index, wasm_config);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_ambisonic_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_ambisonic_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_ambisonic_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_ambisonic>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_ambisonic_t>();
	constNativeP = native;
	native->is_config_supported = wclap_plugin_ambisonic::nativeProxy_is_config_supported<false>;
	native->get_config = wclap_plugin_ambisonic::nativeProxy_get_config<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_ambisonic_t>(const clap_plugin_ambisonic_t *native);

struct wclap_host_ambisonic {
	wclap_host_ambisonic(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & changed() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_ambisonic_t>(ScopedThread &scoped, const clap_host_ambisonic_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_ambisonic_t>(const clap_host_ambisonic_t *native);

struct wclap_audio_port_info {
	wclap_audio_port_info(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 280;
	
	operator bool() const {
		return pointerInWasm;
	}

	uint32_t & id() {
		return *(uint32_t *)pointerInWasm;
	}
	char & name(size_t index) {
		return *(char *)(pointerInWasm + 4 + index);
	}
	uint32_t & flags() {
		return *(uint32_t *)(pointerInWasm + 260);
	}
	uint32_t & channel_count() {
		return *(uint32_t *)(pointerInWasm + 264);
	}
	WasmP & port_type() {
		return *(WasmP *)(pointerInWasm + 272);
	}
	uint32_t & in_place_pair() {
		return *(uint32_t *)(pointerInWasm + 276);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_audio_port_info_t>(ScopedThread &scoped, WasmP wasmP, const clap_audio_port_info_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_audio_port_info_t *&constNativeP) {
	auto wasm = scoped.view<wclap_audio_port_info>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_audio_port_info_t>();
	constNativeP = native;
	native->id = wasm.id();
	for (size_t i = 0; i < 256; ++i) {
		native->name[i] = wasm.name(i);
	}
	native->flags = wasm.flags();
	native->channel_count = wasm.channel_count();
	wasmToNative(scoped, wasm.port_type(), native->port_type);
	native->in_place_pair = wasm.in_place_pair();
}

template<>
void nativeToWasm<const clap_audio_port_info_t>(ScopedThread &scoped, const clap_audio_port_info_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_audio_port_info_t>(const clap_audio_port_info_t *native);

struct wclap_plugin_audio_ports {
	wclap_plugin_audio_ports(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & count() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get() {
		return *(WasmP *)(pointerInWasm + 8);
	}
 
	template<bool realtime=false>
	static uint32_t nativeProxy_count(const clap_plugin_t *plugin, bool is_input) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports>(context.wasmMap.plugin_audio_ports).count();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, is_input);
		return wasmResult;
	}  
	template<bool realtime=false>
	static bool nativeProxy_get(const clap_plugin_t *plugin, uint32_t index, bool is_input, clap_audio_port_info_t *info) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports>(context.wasmMap.plugin_audio_ports).get();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_info;
		nativeToWasm(scoped, info, wasm_info);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, index, is_input, wasm_info);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_audio_ports_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_audio_ports_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_audio_ports_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_audio_ports>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_audio_ports_t>();
	constNativeP = native;
	native->count = wclap_plugin_audio_ports::nativeProxy_count<false>;
	native->get = wclap_plugin_audio_ports::nativeProxy_get<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_audio_ports_t>(const clap_plugin_audio_ports_t *native);

struct wclap_host_audio_ports {
	wclap_host_audio_ports(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & is_rescan_flag_supported() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & rescan() {
		return *(WasmP *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_audio_ports_t>(ScopedThread &scoped, const clap_host_audio_ports_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_audio_ports_t>(const clap_host_audio_ports_t *native);

struct wclap_plugin_audio_ports_activation {
	wclap_plugin_audio_ports_activation(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & can_activate_while_processing() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & set_active() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static bool nativeProxy_can_activate_while_processing(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports_activation>(context.wasmMap.plugin_audio_ports_activation).can_activate_while_processing();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}    
	template<bool realtime=false>
	static bool nativeProxy_set_active(const clap_plugin_t *plugin, bool is_input, uint32_t port_index, bool is_active, uint32_t sample_size) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports_activation>(context.wasmMap.plugin_audio_ports_activation).set_active();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, is_input, port_index, is_active, sample_size);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_audio_ports_activation_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_audio_ports_activation_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_audio_ports_activation_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_audio_ports_activation>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_audio_ports_activation_t>();
	constNativeP = native;
	native->can_activate_while_processing = wclap_plugin_audio_ports_activation::nativeProxy_can_activate_while_processing<false>;
	native->set_active = wclap_plugin_audio_ports_activation::nativeProxy_set_active<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_audio_ports_activation_t>(const clap_plugin_audio_ports_activation_t *native);

struct wclap_audio_ports_config {
	wclap_audio_ports_config(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 296;
	
	operator bool() const {
		return pointerInWasm;
	}

	uint32_t & id() {
		return *(uint32_t *)pointerInWasm;
	}
	char & name(size_t index) {
		return *(char *)(pointerInWasm + 4 + index);
	}
	uint32_t & input_port_count() {
		return *(uint32_t *)(pointerInWasm + 260);
	}
	uint32_t & output_port_count() {
		return *(uint32_t *)(pointerInWasm + 264);
	}
	bool & has_main_input() {
		return *(bool *)(pointerInWasm + 268);
	}
	uint32_t & main_input_channel_count() {
		return *(uint32_t *)(pointerInWasm + 272);
	}
	WasmP & main_input_port_type() {
		return *(WasmP *)(pointerInWasm + 280);
	}
	bool & has_main_output() {
		return *(bool *)(pointerInWasm + 281);
	}
	uint32_t & main_output_channel_count() {
		return *(uint32_t *)(pointerInWasm + 284);
	}
	WasmP & main_output_port_type() {
		return *(WasmP *)(pointerInWasm + 288);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_audio_ports_config_t>(ScopedThread &scoped, WasmP wasmP, const clap_audio_ports_config_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_audio_ports_config_t *&constNativeP) {
	auto wasm = scoped.view<wclap_audio_ports_config>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_audio_ports_config_t>();
	constNativeP = native;
	native->id = wasm.id();
	for (size_t i = 0; i < 256; ++i) {
		native->name[i] = wasm.name(i);
	}
	native->input_port_count = wasm.input_port_count();
	native->output_port_count = wasm.output_port_count();
	native->has_main_input = wasm.has_main_input();
	native->main_input_channel_count = wasm.main_input_channel_count();
	wasmToNative(scoped, wasm.main_input_port_type(), native->main_input_port_type);
	native->has_main_output = wasm.has_main_output();
	native->main_output_channel_count = wasm.main_output_channel_count();
	wasmToNative(scoped, wasm.main_output_port_type(), native->main_output_port_type);
}

template<>
void nativeToWasm<const clap_audio_ports_config_t>(ScopedThread &scoped, const clap_audio_ports_config_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_audio_ports_config_t>(const clap_audio_ports_config_t *native);

struct wclap_plugin_audio_ports_config {
	wclap_plugin_audio_ports_config(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 24;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & count() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & select() {
		return *(WasmP *)(pointerInWasm + 16);
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_count(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports_config>(context.wasmMap.plugin_audio_ports_config).count();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_get(const clap_plugin_t *plugin, uint32_t index, clap_audio_ports_config_t *config) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports_config>(context.wasmMap.plugin_audio_ports_config).get();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_config;
		nativeToWasm(scoped, config, wasm_config);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, index, wasm_config);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_select(const clap_plugin_t *plugin, clap_id config_id) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports_config>(context.wasmMap.plugin_audio_ports_config).select();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, config_id);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_audio_ports_config_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_audio_ports_config_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_audio_ports_config_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_audio_ports_config>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_audio_ports_config_t>();
	constNativeP = native;
	native->count = wclap_plugin_audio_ports_config::nativeProxy_count<false>;
	native->get = wclap_plugin_audio_ports_config::nativeProxy_get<false>;
	native->select = wclap_plugin_audio_ports_config::nativeProxy_select<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_audio_ports_config_t>(const clap_plugin_audio_ports_config_t *native);

struct wclap_plugin_audio_ports_config_info {
	wclap_plugin_audio_ports_config_info(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & current_config() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static clap_id nativeProxy_current_config(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports_config_info>(context.wasmMap.plugin_audio_ports_config_info).current_config();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}   
	template<bool realtime=false>
	static bool nativeProxy_get(const clap_plugin_t *plugin, clap_id config_id, uint32_t port_index, bool is_input, clap_audio_port_info_t *info) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_audio_ports_config_info>(context.wasmMap.plugin_audio_ports_config_info).get();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_info;
		nativeToWasm(scoped, info, wasm_info);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, config_id, port_index, is_input, wasm_info);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_audio_ports_config_info_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_audio_ports_config_info_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_audio_ports_config_info_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_audio_ports_config_info>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_audio_ports_config_info_t>();
	constNativeP = native;
	native->current_config = wclap_plugin_audio_ports_config_info::nativeProxy_current_config<false>;
	native->get = wclap_plugin_audio_ports_config_info::nativeProxy_get<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_audio_ports_config_info_t>(const clap_plugin_audio_ports_config_info_t *native);

struct wclap_host_audio_ports_config {
	wclap_host_audio_ports_config(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & rescan() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_audio_ports_config_t>(ScopedThread &scoped, const clap_host_audio_ports_config_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_audio_ports_config_t>(const clap_host_audio_ports_config_t *native);

struct wclap_audio_port_configuration_request {
	wclap_audio_port_configuration_request(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 32;
	
	operator bool() const {
		return pointerInWasm;
	}

	bool & is_input() {
		return *(bool *)pointerInWasm;
	}
	uint32_t & port_index() {
		return *(uint32_t *)(pointerInWasm + 4);
	}
	uint32_t & channel_count() {
		return *(uint32_t *)(pointerInWasm + 8);
	}
	WasmP & port_type() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & port_details() {
		return *(WasmP *)(pointerInWasm + 24);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_audio_port_configuration_request_t>(ScopedThread &scoped, WasmP wasmP, const clap_audio_port_configuration_request_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_audio_port_configuration_request_t *&constNativeP) {
	auto wasm = scoped.view<wclap_audio_port_configuration_request>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_audio_port_configuration_request_t>();
	constNativeP = native;
	native->is_input = wasm.is_input();
	native->port_index = wasm.port_index();
	native->channel_count = wasm.channel_count();
	wasmToNative(scoped, wasm.port_type(), native->port_type);
	wasmToNative(scoped, wasm.port_details(), native->port_details);
}

template<>
void nativeToWasm<const clap_audio_port_configuration_request_t>(ScopedThread &scoped, const clap_audio_port_configuration_request_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_audio_port_configuration_request_t>(const clap_audio_port_configuration_request_t *native);

struct wclap_plugin_configurable_audio_ports {
	wclap_plugin_configurable_audio_ports(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & can_apply_configuration() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & apply_configuration() {
		return *(WasmP *)(pointerInWasm + 8);
	}
 
	template<bool realtime=false>
	static bool nativeProxy_can_apply_configuration(const clap_plugin_t *plugin, const struct clap_audio_port_configuration_request *requests, uint32_t request_count) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_configurable_audio_ports>(context.wasmMap.plugin_configurable_audio_ports).can_apply_configuration();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_requests;
		nativeToWasm(scoped, requests, wasm_requests);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_requests, request_count);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_apply_configuration(const clap_plugin_t *plugin, const struct clap_audio_port_configuration_request *requests, uint32_t request_count) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_configurable_audio_ports>(context.wasmMap.plugin_configurable_audio_ports).apply_configuration();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_requests;
		nativeToWasm(scoped, requests, wasm_requests);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_requests, request_count);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_configurable_audio_ports_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_configurable_audio_ports_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_configurable_audio_ports_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_configurable_audio_ports>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_configurable_audio_ports_t>();
	constNativeP = native;
	native->can_apply_configuration = wclap_plugin_configurable_audio_ports::nativeProxy_can_apply_configuration<false>;
	native->apply_configuration = wclap_plugin_configurable_audio_ports::nativeProxy_apply_configuration<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_configurable_audio_ports_t>(const clap_plugin_configurable_audio_ports_t *native);

using wclap_context_menu_target = clap_context_menu_target_t;

struct wclap_context_menu_entry {
	wclap_context_menu_entry(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & label() {
		return *(WasmP *)pointerInWasm;
	}
	bool & is_enabled() {
		return *(bool *)(pointerInWasm + 8);
	}
	uint32_t & action_id() {
		return *(uint32_t *)(pointerInWasm + 12);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_context_menu_entry_t>(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_entry_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_entry_t *&constNativeP) {
	auto wasm = scoped.view<wclap_context_menu_entry>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_context_menu_entry_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.label(), native->label);
	native->is_enabled = wasm.is_enabled();
	native->action_id = wasm.action_id();
}

template<>
void nativeToWasm<const clap_context_menu_entry_t>(ScopedThread &scoped, const clap_context_menu_entry_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_context_menu_entry_t>(const clap_context_menu_entry_t *native);

struct wclap_context_menu_check_entry {
	wclap_context_menu_check_entry(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & label() {
		return *(WasmP *)pointerInWasm;
	}
	bool & is_enabled() {
		return *(bool *)(pointerInWasm + 8);
	}
	bool & is_checked() {
		return *(bool *)(pointerInWasm + 9);
	}
	uint32_t & action_id() {
		return *(uint32_t *)(pointerInWasm + 12);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_context_menu_check_entry_t>(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_check_entry_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_check_entry_t *&constNativeP) {
	auto wasm = scoped.view<wclap_context_menu_check_entry>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_context_menu_check_entry_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.label(), native->label);
	native->is_enabled = wasm.is_enabled();
	native->is_checked = wasm.is_checked();
	native->action_id = wasm.action_id();
}

template<>
void nativeToWasm<const clap_context_menu_check_entry_t>(ScopedThread &scoped, const clap_context_menu_check_entry_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_context_menu_check_entry_t>(const clap_context_menu_check_entry_t *native);

struct wclap_context_menu_item_title {
	wclap_context_menu_item_title(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & title() {
		return *(WasmP *)pointerInWasm;
	}
	bool & is_enabled() {
		return *(bool *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_context_menu_item_title_t>(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_item_title_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_item_title_t *&constNativeP) {
	auto wasm = scoped.view<wclap_context_menu_item_title>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_context_menu_item_title_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.title(), native->title);
	native->is_enabled = wasm.is_enabled();
}

template<>
void nativeToWasm<const clap_context_menu_item_title_t>(ScopedThread &scoped, const clap_context_menu_item_title_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_context_menu_item_title_t>(const clap_context_menu_item_title_t *native);

struct wclap_context_menu_submenu {
	wclap_context_menu_submenu(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & label() {
		return *(WasmP *)pointerInWasm;
	}
	bool & is_enabled() {
		return *(bool *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_context_menu_submenu_t>(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_submenu_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_submenu_t *&constNativeP) {
	auto wasm = scoped.view<wclap_context_menu_submenu>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_context_menu_submenu_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.label(), native->label);
	native->is_enabled = wasm.is_enabled();
}

template<>
void nativeToWasm<const clap_context_menu_submenu_t>(ScopedThread &scoped, const clap_context_menu_submenu_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_context_menu_submenu_t>(const clap_context_menu_submenu_t *native);

struct wclap_context_menu_builder {
	wclap_context_menu_builder(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 24;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & ctx() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & add_item() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & supports() {
		return *(WasmP *)(pointerInWasm + 16);
	}
 
	template<bool realtime=false>
	static bool nativeProxy_add_item(const struct clap_context_menu_builder *builder, clap_context_menu_item_kind_t item_kind, const void *item_data) {
		auto &context = getNativeProxyContext(builder);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_context_menu_builder>(context.wasmMap.context_menu_builder).add_item();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_item_data;
		nativeToWasm(scoped, item_data, wasm_item_data);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.context_menu_builder, item_kind, wasm_item_data);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_supports(const struct clap_context_menu_builder *builder, clap_context_menu_item_kind_t item_kind) {
		auto &context = getNativeProxyContext(builder);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_context_menu_builder>(context.wasmMap.context_menu_builder).supports();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.context_menu_builder, item_kind);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_context_menu_builder_t>(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_builder_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_context_menu_builder_t *&constNativeP) {
	auto wasm = scoped.view<wclap_context_menu_builder>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_context_menu_builder_t>();
	constNativeP = native;
	wasmToNative(scoped, wasm.ctx(), native->ctx);
	native->add_item = wclap_context_menu_builder::nativeProxy_add_item<false>;
	native->supports = wclap_context_menu_builder::nativeProxy_supports<false>;
}

template<>
void nativeToWasm<const clap_context_menu_builder_t>(ScopedThread &scoped, const clap_context_menu_builder_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_context_menu_builder_t>(const clap_context_menu_builder_t *native);

struct wclap_plugin_context_menu {
	wclap_plugin_context_menu(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & populate() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & perform() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static bool nativeProxy_populate(const clap_plugin_t *plugin, const clap_context_menu_target_t *target, const clap_context_menu_builder_t *builder) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_context_menu>(context.wasmMap.plugin_context_menu).populate();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_target;
		nativeToWasm(scoped, target, wasm_target);
		WasmP wasm_builder;
		nativeToWasm(scoped, builder, wasm_builder);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_target, wasm_builder);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_perform(const clap_plugin_t *plugin, const clap_context_menu_target_t *target, clap_id action_id) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_context_menu>(context.wasmMap.plugin_context_menu).perform();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_target;
		nativeToWasm(scoped, target, wasm_target);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_target, action_id);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_context_menu_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_context_menu_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_context_menu_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_context_menu>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_context_menu_t>();
	constNativeP = native;
	native->populate = wclap_plugin_context_menu::nativeProxy_populate<false>;
	native->perform = wclap_plugin_context_menu::nativeProxy_perform<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_context_menu_t>(const clap_plugin_context_menu_t *native);

struct wclap_host_context_menu {
	wclap_host_context_menu(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 32;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & populate() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & perform() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & can_popup() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & popup() {
		return *(WasmP *)(pointerInWasm + 24);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_context_menu_t>(ScopedThread &scoped, const clap_host_context_menu_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_context_menu_t>(const clap_host_context_menu_t *native);

struct wclap_host_event_registry {
	wclap_host_event_registry(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & query() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_event_registry_t>(ScopedThread &scoped, const clap_host_event_registry_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_event_registry_t>(const clap_host_event_registry_t *native);

using wclap_gui_resize_hints = clap_gui_resize_hints_t;

struct wclap_plugin_gui {
	wclap_plugin_gui(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 120;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & is_api_supported() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get_preferred_api() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & create() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & destroy() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & set_scale() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & get_size() {
		return *(WasmP *)(pointerInWasm + 40);
	}
	WasmP & can_resize() {
		return *(WasmP *)(pointerInWasm + 48);
	}
	WasmP & get_resize_hints() {
		return *(WasmP *)(pointerInWasm + 56);
	}
	WasmP & adjust_size() {
		return *(WasmP *)(pointerInWasm + 64);
	}
	WasmP & set_size() {
		return *(WasmP *)(pointerInWasm + 72);
	}
	WasmP & set_parent() {
		return *(WasmP *)(pointerInWasm + 80);
	}
	WasmP & set_transient() {
		return *(WasmP *)(pointerInWasm + 88);
	}
	WasmP & suggest_title() {
		return *(WasmP *)(pointerInWasm + 96);
	}
	WasmP & show() {
		return *(WasmP *)(pointerInWasm + 104);
	}
	WasmP & hide() {
		return *(WasmP *)(pointerInWasm + 112);
	}
 
	template<bool realtime=false>
	static bool nativeProxy_is_api_supported(const clap_plugin_t *plugin, const char *api, bool is_floating) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).is_api_supported();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_api;
		nativeToWasm(scoped, api, wasm_api);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_api, is_floating);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_get_preferred_api(const clap_plugin_t *plugin, const char **api, bool *is_floating) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).get_preferred_api();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_api;
		nativeToWasm(scoped, api, wasm_api);
		WasmP wasm_is_floating;
		nativeToWasm(scoped, is_floating, wasm_is_floating);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_api, wasm_is_floating);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_create(const clap_plugin_t *plugin, const char *api, bool is_floating) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).create();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_api;
		nativeToWasm(scoped, api, wasm_api);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_api, is_floating);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_destroy(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).destroy();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin);
	} 
	template<bool realtime=false>
	static bool nativeProxy_set_scale(const clap_plugin_t *plugin, double scale) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).set_scale();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, scale);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_get_size(const clap_plugin_t *plugin, uint32_t *width, uint32_t *height) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).get_size();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_width;
		nativeToWasm(scoped, width, wasm_width);
		WasmP wasm_height;
		nativeToWasm(scoped, height, wasm_height);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_width, wasm_height);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_can_resize(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).can_resize();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_get_resize_hints(const clap_plugin_t *plugin, clap_gui_resize_hints_t *hints) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).get_resize_hints();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_hints;
		nativeToWasm(scoped, hints, wasm_hints);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_hints);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_adjust_size(const clap_plugin_t *plugin, uint32_t *width, uint32_t *height) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).adjust_size();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_width;
		nativeToWasm(scoped, width, wasm_width);
		WasmP wasm_height;
		nativeToWasm(scoped, height, wasm_height);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_width, wasm_height);
		return wasmResult;
	}  
	template<bool realtime=false>
	static bool nativeProxy_set_size(const clap_plugin_t *plugin, uint32_t width, uint32_t height) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).set_size();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, width, height);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_set_parent(const clap_plugin_t *plugin, const clap_window_t *window) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).set_parent();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_window;
		nativeToWasm(scoped, window, wasm_window);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_window);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_set_transient(const clap_plugin_t *plugin, const clap_window_t *window) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).set_transient();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_window;
		nativeToWasm(scoped, window, wasm_window);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_window);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_suggest_title(const clap_plugin_t *plugin, const char *title) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).suggest_title();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_title;
		nativeToWasm(scoped, title, wasm_title);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin, wasm_title);
	}
	template<bool realtime=false>
	static bool nativeProxy_show(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).show();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_hide(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_gui>(context.wasmMap.plugin_gui).hide();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_gui_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_gui_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_gui_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_gui>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_gui_t>();
	constNativeP = native;
	native->is_api_supported = wclap_plugin_gui::nativeProxy_is_api_supported<false>;
	native->get_preferred_api = wclap_plugin_gui::nativeProxy_get_preferred_api<false>;
	native->create = wclap_plugin_gui::nativeProxy_create<false>;
	native->destroy = wclap_plugin_gui::nativeProxy_destroy<false>;
	native->set_scale = wclap_plugin_gui::nativeProxy_set_scale<false>;
	native->get_size = wclap_plugin_gui::nativeProxy_get_size<false>;
	native->can_resize = wclap_plugin_gui::nativeProxy_can_resize<false>;
	native->get_resize_hints = wclap_plugin_gui::nativeProxy_get_resize_hints<false>;
	native->adjust_size = wclap_plugin_gui::nativeProxy_adjust_size<false>;
	native->set_size = wclap_plugin_gui::nativeProxy_set_size<false>;
	native->set_parent = wclap_plugin_gui::nativeProxy_set_parent<false>;
	native->set_transient = wclap_plugin_gui::nativeProxy_set_transient<false>;
	native->suggest_title = wclap_plugin_gui::nativeProxy_suggest_title<false>;
	native->show = wclap_plugin_gui::nativeProxy_show<false>;
	native->hide = wclap_plugin_gui::nativeProxy_hide<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_gui_t>(const clap_plugin_gui_t *native);

struct wclap_host_gui {
	wclap_host_gui(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 40;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & resize_hints_changed() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & request_resize() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & request_show() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & request_hide() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & closed() {
		return *(WasmP *)(pointerInWasm + 32);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_gui_t>(ScopedThread &scoped, const clap_host_gui_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_gui_t>(const clap_host_gui_t *native);

struct wclap_plugin_latency {
	wclap_plugin_latency(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & get() {
		return *(WasmP *)pointerInWasm;
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_get(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_latency>(context.wasmMap.plugin_latency).get();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_latency_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_latency_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_latency_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_latency>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_latency_t>();
	constNativeP = native;
	native->get = wclap_plugin_latency::nativeProxy_get<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_latency_t>(const clap_plugin_latency_t *native);

struct wclap_host_latency {
	wclap_host_latency(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & changed() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_latency_t>(ScopedThread &scoped, const clap_host_latency_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_latency_t>(const clap_host_latency_t *native);

struct wclap_host_log {
	wclap_host_log(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & log() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_log_t>(ScopedThread &scoped, const clap_host_log_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_log_t>(const clap_host_log_t *native);

using wclap_note_name = clap_note_name_t;

struct wclap_plugin_note_name {
	wclap_plugin_note_name(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & count() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_count(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_note_name>(context.wasmMap.plugin_note_name).count();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_get(const clap_plugin_t *plugin, uint32_t index, clap_note_name_t *note_name) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_note_name>(context.wasmMap.plugin_note_name).get();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_note_name;
		nativeToWasm(scoped, note_name, wasm_note_name);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, index, wasm_note_name);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_note_name_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_note_name_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_note_name_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_note_name>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_note_name_t>();
	constNativeP = native;
	native->count = wclap_plugin_note_name::nativeProxy_count<false>;
	native->get = wclap_plugin_note_name::nativeProxy_get<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_note_name_t>(const clap_plugin_note_name_t *native);

struct wclap_host_note_name {
	wclap_host_note_name(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & changed() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_note_name_t>(ScopedThread &scoped, const clap_host_note_name_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_note_name_t>(const clap_host_note_name_t *native);

using wclap_note_port_info = clap_note_port_info_t;

struct wclap_plugin_note_ports {
	wclap_plugin_note_ports(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & count() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get() {
		return *(WasmP *)(pointerInWasm + 8);
	}
 
	template<bool realtime=false>
	static uint32_t nativeProxy_count(const clap_plugin_t *plugin, bool is_input) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_note_ports>(context.wasmMap.plugin_note_ports).count();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, is_input);
		return wasmResult;
	}  
	template<bool realtime=false>
	static bool nativeProxy_get(const clap_plugin_t *plugin, uint32_t index, bool is_input, clap_note_port_info_t *info) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_note_ports>(context.wasmMap.plugin_note_ports).get();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_info;
		nativeToWasm(scoped, info, wasm_info);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, index, is_input, wasm_info);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_note_ports_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_note_ports_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_note_ports_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_note_ports>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_note_ports_t>();
	constNativeP = native;
	native->count = wclap_plugin_note_ports::nativeProxy_count<false>;
	native->get = wclap_plugin_note_ports::nativeProxy_get<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_note_ports_t>(const clap_plugin_note_ports_t *native);

struct wclap_host_note_ports {
	wclap_host_note_ports(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & supported_dialects() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & rescan() {
		return *(WasmP *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_note_ports_t>(ScopedThread &scoped, const clap_host_note_ports_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_note_ports_t>(const clap_host_note_ports_t *native);

struct wclap_plugin_param_indication {
	wclap_plugin_param_indication(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & set_mapping() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & set_automation() {
		return *(WasmP *)(pointerInWasm + 8);
	}
  
	template<bool realtime=false>
	static void nativeProxy_set_mapping(const clap_plugin_t *plugin, clap_id param_id, bool has_mapping, const clap_color_t *color, const char *label, const char *description) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_param_indication>(context.wasmMap.plugin_param_indication).set_mapping();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_color;
		nativeToWasm(scoped, color, wasm_color);
		WasmP wasm_label;
		nativeToWasm(scoped, label, wasm_label);
		WasmP wasm_description;
		nativeToWasm(scoped, description, wasm_description);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin, param_id, has_mapping, wasm_color, wasm_label, wasm_description);
	}  
	template<bool realtime=false>
	static void nativeProxy_set_automation(const clap_plugin_t *plugin, clap_id param_id, uint32_t automation_state, const clap_color_t *color) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_param_indication>(context.wasmMap.plugin_param_indication).set_automation();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_color;
		nativeToWasm(scoped, color, wasm_color);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin, param_id, automation_state, wasm_color);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_param_indication_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_param_indication_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_param_indication_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_param_indication>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_param_indication_t>();
	constNativeP = native;
	native->set_mapping = wclap_plugin_param_indication::nativeProxy_set_mapping<false>;
	native->set_automation = wclap_plugin_param_indication::nativeProxy_set_automation<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_param_indication_t>(const clap_plugin_param_indication_t *native);

struct wclap_param_info {
	wclap_param_info(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 1320;
	
	operator bool() const {
		return pointerInWasm;
	}

	uint32_t & id() {
		return *(uint32_t *)pointerInWasm;
	}
	uint32_t & flags() {
		return *(uint32_t *)(pointerInWasm + 4);
	}
	WasmP & cookie() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	char & name(size_t index) {
		return *(char *)(pointerInWasm + 16 + index);
	}
	char & module(size_t index) {
		return *(char *)(pointerInWasm + 272 + index);
	}
	double & min_value() {
		return *(double *)(pointerInWasm + 1296);
	}
	double & max_value() {
		return *(double *)(pointerInWasm + 1304);
	}
	double & default_value() {
		return *(double *)(pointerInWasm + 1312);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_param_info_t>(ScopedThread &scoped, WasmP wasmP, const clap_param_info_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_param_info_t *&constNativeP) {
	auto wasm = scoped.view<wclap_param_info>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_param_info_t>();
	constNativeP = native;
	native->id = wasm.id();
	native->flags = wasm.flags();
	wasmToNative(scoped, wasm.cookie(), native->cookie);
	for (size_t i = 0; i < 256; ++i) {
		native->name[i] = wasm.name(i);
	}
	for (size_t i = 0; i < 1024; ++i) {
		native->module[i] = wasm.module(i);
	}
	native->min_value = wasm.min_value();
	native->max_value = wasm.max_value();
	native->default_value = wasm.default_value();
}

template<>
void nativeToWasm<const clap_param_info_t>(ScopedThread &scoped, const clap_param_info_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_param_info_t>(const clap_param_info_t *native);

struct wclap_plugin_params {
	wclap_plugin_params(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 48;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & count() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get_info() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & get_value() {
		return *(WasmP *)(pointerInWasm + 16);
	}
	WasmP & value_to_text() {
		return *(WasmP *)(pointerInWasm + 24);
	}
	WasmP & text_to_value() {
		return *(WasmP *)(pointerInWasm + 32);
	}
	WasmP & flush() {
		return *(WasmP *)(pointerInWasm + 40);
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_count(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_params>(context.wasmMap.plugin_params).count();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_get_info(const clap_plugin_t *plugin, uint32_t param_index, clap_param_info_t *param_info) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_params>(context.wasmMap.plugin_params).get_info();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_param_info;
		nativeToWasm(scoped, param_info, wasm_param_info);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, param_index, wasm_param_info);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_get_value(const clap_plugin_t *plugin, clap_id param_id, double *out_value) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_params>(context.wasmMap.plugin_params).get_value();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_out_value;
		nativeToWasm(scoped, out_value, wasm_out_value);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, param_id, wasm_out_value);
		return wasmResult;
	}   
	template<bool realtime=false>
	static bool nativeProxy_value_to_text(const clap_plugin_t *plugin, clap_id param_id, double value, char *out_buffer, uint32_t out_buffer_capacity) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_params>(context.wasmMap.plugin_params).value_to_text();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_out_buffer;
		nativeToWasm(scoped, out_buffer, wasm_out_buffer);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, param_id, value, wasm_out_buffer, out_buffer_capacity);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_text_to_value(const clap_plugin_t *plugin, clap_id param_id, const char *param_value_text, double *out_value) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_params>(context.wasmMap.plugin_params).text_to_value();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_param_value_text;
		nativeToWasm(scoped, param_value_text, wasm_param_value_text);
		WasmP wasm_out_value;
		nativeToWasm(scoped, out_value, wasm_out_value);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, param_id, wasm_param_value_text, wasm_out_value);
		return wasmResult;
	}
	template<bool realtime=false>
	static void nativeProxy_flush(const clap_plugin_t *plugin, const clap_input_events_t *in, const clap_output_events_t *out) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_params>(context.wasmMap.plugin_params).flush();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_in;
		nativeToWasm(scoped, in, wasm_in);
		WasmP wasm_out;
		nativeToWasm(scoped, out, wasm_out);
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin, wasm_in, wasm_out);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_params_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_params_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_params_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_params>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_params_t>();
	constNativeP = native;
	native->count = wclap_plugin_params::nativeProxy_count<false>;
	native->get_info = wclap_plugin_params::nativeProxy_get_info<false>;
	native->get_value = wclap_plugin_params::nativeProxy_get_value<false>;
	native->value_to_text = wclap_plugin_params::nativeProxy_value_to_text<false>;
	native->text_to_value = wclap_plugin_params::nativeProxy_text_to_value<false>;
	native->flush = wclap_plugin_params::nativeProxy_flush<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_params_t>(const clap_plugin_params_t *native);

struct wclap_host_params {
	wclap_host_params(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 24;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & rescan() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & clear() {
		return *(WasmP *)(pointerInWasm + 8);
	}
	WasmP & request_flush() {
		return *(WasmP *)(pointerInWasm + 16);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_params_t>(ScopedThread &scoped, const clap_host_params_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_params_t>(const clap_host_params_t *native);

struct wclap_plugin_preset_load {
	wclap_plugin_preset_load(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & from_location() {
		return *(WasmP *)pointerInWasm;
	}
 
	template<bool realtime=false>
	static bool nativeProxy_from_location(const clap_plugin_t *plugin, uint32_t location_kind, const char *location, const char *load_key) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_preset_load>(context.wasmMap.plugin_preset_load).from_location();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_location;
		nativeToWasm(scoped, location, wasm_location);
		WasmP wasm_load_key;
		nativeToWasm(scoped, load_key, wasm_load_key);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, location_kind, wasm_location, wasm_load_key);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_preset_load_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_preset_load_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_preset_load_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_preset_load>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_preset_load_t>();
	constNativeP = native;
	native->from_location = wclap_plugin_preset_load::nativeProxy_from_location<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_preset_load_t>(const clap_plugin_preset_load_t *native);

struct wclap_host_preset_load {
	wclap_host_preset_load(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & on_error() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & loaded() {
		return *(WasmP *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_preset_load_t>(ScopedThread &scoped, const clap_host_preset_load_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_preset_load_t>(const clap_host_preset_load_t *native);

using wclap_remote_controls_page = clap_remote_controls_page_t;

struct wclap_plugin_remote_controls {
	wclap_plugin_remote_controls(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & count() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_count(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_remote_controls>(context.wasmMap.plugin_remote_controls).count();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_get(const clap_plugin_t *plugin, uint32_t page_index, clap_remote_controls_page_t *page) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_remote_controls>(context.wasmMap.plugin_remote_controls).get();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_page;
		nativeToWasm(scoped, page, wasm_page);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, page_index, wasm_page);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_remote_controls_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_remote_controls_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_remote_controls_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_remote_controls>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_remote_controls_t>();
	constNativeP = native;
	native->count = wclap_plugin_remote_controls::nativeProxy_count<false>;
	native->get = wclap_plugin_remote_controls::nativeProxy_get<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_remote_controls_t>(const clap_plugin_remote_controls_t *native);

struct wclap_host_remote_controls {
	wclap_host_remote_controls(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & changed() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & suggest_page() {
		return *(WasmP *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_remote_controls_t>(ScopedThread &scoped, const clap_host_remote_controls_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_remote_controls_t>(const clap_host_remote_controls_t *native);

struct wclap_plugin_render {
	wclap_plugin_render(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & has_hard_realtime_requirement() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & set() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static bool nativeProxy_has_hard_realtime_requirement(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_render>(context.wasmMap.plugin_render).has_hard_realtime_requirement();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_set(const clap_plugin_t *plugin, clap_plugin_render_mode mode) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_render>(context.wasmMap.plugin_render).set();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, mode);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_render_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_render_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_render_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_render>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_render_t>();
	constNativeP = native;
	native->has_hard_realtime_requirement = wclap_plugin_render::nativeProxy_has_hard_realtime_requirement<false>;
	native->set = wclap_plugin_render::nativeProxy_set<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_render_t>(const clap_plugin_render_t *native);

struct wclap_plugin_state_context {
	wclap_plugin_state_context(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & save() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & load() {
		return *(WasmP *)(pointerInWasm + 8);
	}
 
	template<bool realtime=false>
	static bool nativeProxy_save(const clap_plugin_t *plugin, const clap_ostream_t *stream, uint32_t context_type) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_state_context>(context.wasmMap.plugin_state_context).save();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_stream;
		nativeToWasm(scoped, stream, wasm_stream);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_stream, context_type);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_load(const clap_plugin_t *plugin, const clap_istream_t *stream, uint32_t context_type) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_state_context>(context.wasmMap.plugin_state_context).load();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_stream;
		nativeToWasm(scoped, stream, wasm_stream);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_stream, context_type);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_state_context_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_state_context_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_state_context_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_state_context>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_state_context_t>();
	constNativeP = native;
	native->save = wclap_plugin_state_context::nativeProxy_save<false>;
	native->load = wclap_plugin_state_context::nativeProxy_load<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_state_context_t>(const clap_plugin_state_context_t *native);

struct wclap_plugin_state {
	wclap_plugin_state(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & save() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & load() {
		return *(WasmP *)(pointerInWasm + 8);
	}

	template<bool realtime=false>
	static bool nativeProxy_save(const clap_plugin_t *plugin, const clap_ostream_t *stream) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_state>(context.wasmMap.plugin_state).save();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_stream;
		nativeToWasm(scoped, stream, wasm_stream);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_stream);
		return wasmResult;
	}
	template<bool realtime=false>
	static bool nativeProxy_load(const clap_plugin_t *plugin, const clap_istream_t *stream) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_state>(context.wasmMap.plugin_state).load();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_stream;
		nativeToWasm(scoped, stream, wasm_stream);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_stream);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_state_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_state_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_state_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_state>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_state_t>();
	constNativeP = native;
	native->save = wclap_plugin_state::nativeProxy_save<false>;
	native->load = wclap_plugin_state::nativeProxy_load<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_state_t>(const clap_plugin_state_t *native);

struct wclap_host_state {
	wclap_host_state(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & mark_dirty() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_state_t>(ScopedThread &scoped, const clap_host_state_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_state_t>(const clap_host_state_t *native);

struct wclap_plugin_surround {
	wclap_plugin_surround(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & is_channel_mask_supported() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & get_channel_map() {
		return *(WasmP *)(pointerInWasm + 8);
	}
 
	template<bool realtime=false>
	static bool nativeProxy_is_channel_mask_supported(const clap_plugin_t *plugin, uint64_t channel_mask) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_surround>(context.wasmMap.plugin_surround).is_channel_mask_supported();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, channel_mask);
		return wasmResult;
	}   
	template<bool realtime=false>
	static uint32_t nativeProxy_get_channel_map(const clap_plugin_t *plugin, bool is_input, uint32_t port_index, uint8_t *channel_map, uint32_t channel_map_capacity) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_surround>(context.wasmMap.plugin_surround).get_channel_map();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_channel_map;
		nativeToWasm(scoped, channel_map, wasm_channel_map);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, is_input, port_index, wasm_channel_map, channel_map_capacity);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_surround_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_surround_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_surround_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_surround>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_surround_t>();
	constNativeP = native;
	native->is_channel_mask_supported = wclap_plugin_surround::nativeProxy_is_channel_mask_supported<false>;
	native->get_channel_map = wclap_plugin_surround::nativeProxy_get_channel_map<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_surround_t>(const clap_plugin_surround_t *native);

struct wclap_host_surround {
	wclap_host_surround(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & changed() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_surround_t>(ScopedThread &scoped, const clap_host_surround_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_surround_t>(const clap_host_surround_t *native);

struct wclap_plugin_tail {
	wclap_plugin_tail(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & get() {
		return *(WasmP *)pointerInWasm;
	}

	template<bool realtime=false>
	static uint32_t nativeProxy_get(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_tail>(context.wasmMap.plugin_tail).get();
		
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_tail_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_tail_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_tail_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_tail>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_tail_t>();
	constNativeP = native;
	native->get = wclap_plugin_tail::nativeProxy_get<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_tail_t>(const clap_plugin_tail_t *native);

struct wclap_host_tail {
	wclap_host_tail(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & changed() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_tail_t>(ScopedThread &scoped, const clap_host_tail_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_tail_t>(const clap_host_tail_t *native);

struct wclap_host_thread_check {
	wclap_host_thread_check(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & is_main_thread() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & is_audio_thread() {
		return *(WasmP *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_thread_check_t>(ScopedThread &scoped, const clap_host_thread_check_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_thread_check_t>(const clap_host_thread_check_t *native);

struct wclap_plugin_thread_pool {
	wclap_plugin_thread_pool(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & exec() {
		return *(WasmP *)pointerInWasm;
	}
 
	template<bool realtime=false>
	static void nativeProxy_exec(const clap_plugin_t *plugin, uint32_t task_index) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_thread_pool>(context.wasmMap.plugin_thread_pool).exec();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin, task_index);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_thread_pool_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_thread_pool_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_thread_pool_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_thread_pool>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_thread_pool_t>();
	constNativeP = native;
	native->exec = wclap_plugin_thread_pool::nativeProxy_exec<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_thread_pool_t>(const clap_plugin_thread_pool_t *native);

struct wclap_host_thread_pool {
	wclap_host_thread_pool(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & request_exec() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_thread_pool_t>(ScopedThread &scoped, const clap_host_thread_pool_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_thread_pool_t>(const clap_host_thread_pool_t *native);

struct wclap_plugin_timer_support {
	wclap_plugin_timer_support(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & on_timer() {
		return *(WasmP *)pointerInWasm;
	}
 
	template<bool realtime=false>
	static void nativeProxy_on_timer(const clap_plugin_t *plugin, clap_id timer_id) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_timer_support>(context.wasmMap.plugin_timer_support).on_timer();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin, timer_id);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_timer_support_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_timer_support_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_timer_support_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_timer_support>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_timer_support_t>();
	constNativeP = native;
	native->on_timer = wclap_plugin_timer_support::nativeProxy_on_timer<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_timer_support_t>(const clap_plugin_timer_support_t *native);

struct wclap_host_timer_support {
	wclap_host_timer_support(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & register_timer() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & unregister_timer() {
		return *(WasmP *)(pointerInWasm + 8);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_timer_support_t>(ScopedThread &scoped, const clap_host_timer_support_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_timer_support_t>(const clap_host_timer_support_t *native);

struct wclap_track_info {
	wclap_track_info(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 280;
	
	operator bool() const {
		return pointerInWasm;
	}

	uint64_t & flags() {
		return *(uint64_t *)pointerInWasm;
	}
	char & name(size_t index) {
		return *(char *)(pointerInWasm + 8 + index);
	}
	clap_color_t & color() {
		return *(clap_color_t *)(pointerInWasm + 264);
	}
	int32_t & audio_channel_count() {
		return *(int32_t *)(pointerInWasm + 268);
	}
	WasmP & audio_port_type() {
		return *(WasmP *)(pointerInWasm + 272);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_track_info_t>(ScopedThread &scoped, WasmP wasmP, const clap_track_info_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_track_info_t *&constNativeP) {
	auto wasm = scoped.view<wclap_track_info>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_track_info_t>();
	constNativeP = native;
	native->flags = wasm.flags();
	for (size_t i = 0; i < 256; ++i) {
		native->name[i] = wasm.name(i);
	}
	native->color = wasm.color();
	native->audio_channel_count = wasm.audio_channel_count();
	wasmToNative(scoped, wasm.audio_port_type(), native->audio_port_type);
}

template<>
void nativeToWasm<const clap_track_info_t>(ScopedThread &scoped, const clap_track_info_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_track_info_t>(const clap_track_info_t *native);

struct wclap_plugin_track_info {
	wclap_plugin_track_info(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & changed() {
		return *(WasmP *)pointerInWasm;
	}

	template<bool realtime=false>
	static void nativeProxy_changed(const clap_plugin_t *plugin) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_track_info>(context.wasmMap.plugin_track_info).changed();
		
		scoped.thread.callWasm_V(wasmFn, context.wasmMap.plugin);
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_track_info_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_track_info_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_track_info_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_track_info>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_track_info_t>();
	constNativeP = native;
	native->changed = wclap_plugin_track_info::nativeProxy_changed<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_track_info_t>(const clap_plugin_track_info_t *native);

struct wclap_host_track_info {
	wclap_host_track_info(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & get() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_track_info_t>(ScopedThread &scoped, const clap_host_track_info_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_track_info_t>(const clap_host_track_info_t *native);

using wclap_voice_info = clap_voice_info_t;

struct wclap_plugin_voice_info {
	wclap_plugin_voice_info(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & get() {
		return *(WasmP *)pointerInWasm;
	}

	template<bool realtime=false>
	static bool nativeProxy_get(const clap_plugin_t *plugin, clap_voice_info_t *info) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_voice_info>(context.wasmMap.plugin_voice_info).get();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_info;
		nativeToWasm(scoped, info, wasm_info);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_info);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_voice_info_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_voice_info_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_voice_info_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_voice_info>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_voice_info_t>();
	constNativeP = native;
	native->get = wclap_plugin_voice_info::nativeProxy_get<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_voice_info_t>(const clap_plugin_voice_info_t *native);

struct wclap_host_voice_info {
	wclap_host_voice_info(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & changed() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_voice_info_t>(ScopedThread &scoped, const clap_host_voice_info_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_voice_info_t>(const clap_host_voice_info_t *native);

struct wclap_plugin_webview {
	wclap_plugin_webview(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 16;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & get_uri() {
		return *(WasmP *)pointerInWasm;
	}
	WasmP & receive() {
		return *(WasmP *)(pointerInWasm + 8);
	}
 
	template<bool realtime=false>
	static int32_t  nativeProxy_get_uri(const clap_plugin_t *plugin, char *uri, uint32_t uri_capacity) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_webview>(context.wasmMap.plugin_webview).get_uri();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_uri;
		nativeToWasm(scoped, uri, wasm_uri);
		int32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_uri, uri_capacity);
		return wasmResult;
	} 
	template<bool realtime=false>
	static bool nativeProxy_receive(const clap_plugin_t *plugin, const void *buffer, uint32_t size) {
		auto &context = getNativeProxyContext(plugin);
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<wclap_plugin_webview>(context.wasmMap.plugin_webview).receive();
		
		auto resetW = scoped.arenas.scopedWasmReset();
		
		WasmP wasm_buffer;
		nativeToWasm(scoped, buffer, wasm_buffer);
		uint32_t wasmResult = scoped.thread.callWasm_I(wasmFn, context.wasmMap.plugin, wasm_buffer, size);
		return wasmResult;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void wasmToNative<const clap_plugin_webview_t>(ScopedThread &scoped, WasmP wasmP, const clap_plugin_webview_t *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const clap_plugin_webview_t *&constNativeP) {
	auto wasm = scoped.view<wclap_plugin_webview>(wasmP);
	auto *native = scoped.arenas.nativeTyped<clap_plugin_webview_t>();
	constNativeP = native;
	native->get_uri = wclap_plugin_webview::nativeProxy_get_uri<false>;
	native->receive = wclap_plugin_webview::nativeProxy_receive<false>;
}

template<>
void * & nativeProxyContextPointer<clap_plugin_webview_t>(const clap_plugin_webview_t *native);

struct wclap_host_webview {
	wclap_host_webview(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = 8;
	static constexpr size_t wasmSize = 8;
	
	operator bool() const {
		return pointerInWasm;
	}

	WasmP & send() {
		return *(WasmP *)pointerInWasm;
	}
private:
	unsigned char *pointerInWasm;
};

template<>
void nativeToWasm<const clap_host_webview_t>(ScopedThread &scoped, const clap_host_webview_t *native, WasmP &wasmP);

template<>
void * & nativeProxyContextPointer<clap_host_webview_t>(const clap_host_webview_t *native);
	
}} // namespace
