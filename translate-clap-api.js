const fs = require('fs');

const clapPrefix = __dirname + "/modules/clap/include/clap/";
const wasmPointerType = 'uint32_t';
const wasmPointerSize = 4;

let code = "/* Generated by translate-clap-api.js */\n";
let customFields = {};
let objectContextFields = {}
let aliases = {};
let types = {};
function normaliseTypeName(name) {
	name = name.replace(/\s+/g, ' ');
	for (let key in aliases) {
		name = (' ' + name + ' ').split(' ' + key + ' ').join(' ' + aliases[key] + ' ').trim();
	}
	name = name.replace(/\s*\*\s*/g, ' * ').replace(/\*\s*\*/g, '**').replace(/(^| )struct ([a-zA-Z_][a-zA-Z0-9_]*)/g, '$1$2_t').trim().replace(/(^| )const ([a-zA-Z_][a-zA-Z0-9_]*)_t/g, '$1$2_t');
	return name;
}

const pointerType = {
	compatible: false,
	wasmType: wasmPointerType,
	wasmSize: wasmPointerSize,
	wasmAlign: wasmPointerSize
}

function addCustom(name, field, typeObj) {
	customFields[name] = customFields[name] || {};
	customFields[name][field] = Object.assign(Object.assign({}, pointerType), typeObj || {});
}

function addAlias(aliasName, canonicalName) {
	aliases[aliasName] = canonicalName;
}

function addObjectContextField(name, field) {
	addCustom(name, field, pointerType);
	objectContextFields[name] = field;
}

function addDirectPointer(name) {
	code += `
// Translate: ${name} *
template<>
struct Wclap::Translate<${name} *> {
	using WasmType = uint32_t;
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType p, ${name} *nativeP) {
		void *nativeInWasm = translate->nativeInWasm(p);
		*nativeP = *(${name} *)nativeInWasm;
	}
	static ${name} * wasmToNative(WclapTranslationScope *translate, WasmType wasmP) {
		if (!wasmP) return nullptr;
		void *nativeInWasm = translate->nativeInWasm(wasmP);
		return (${name} *)nativeInWasm;
	}
	static void assignNativeToWasm(WclapTranslationScope *translate, ${name} *nativeP, WasmType wasmP) {
		void *nativeInWasm = translate->nativeInWasm(wasmP);
		*(${name} *)nativeInWasm = *nativeP;
	}
	static WasmType nativeToWasm(WclapTranslationScope *translate, ${name} *nativeP) {
		if (!nativeP) return 0;
		uint32_t wasmP = translate->temporaryWasmBytes(sizeof(${name}), alignof(${name}));
		assignNativeToWasm(translate, nativeP, wasmP);
		return wasmP;
	}
};`;
}
function addDirect(type, compatible, wasmSize, wasmAlign, wasmType) {
	types[type] = {
		compatible: compatible,
		wasmType: /\*$/.test(type) ? wasmPointerType : type,
		wasmSize: wasmSize,
		wasmAlign: wasmAlign || wasmSize
	};
}
function addFile(path) {
	let cpp = fs.readFileSync(clapPrefix + path, 'utf-8');
	
	cpp = cpp.replace(/CLAP_NAME_SIZE/g, 256);
	cpp = cpp.replace(/CLAP_PATH_SIZE/g, 1024);
	cpp = cpp.replace(/CLAP_REMOTE_CONTROLS_COUNT/g, 8);
	
	cpp.replaceAll(/typedef\s+([^\{\};]+)\s+([a-zA-Z_][a-zA-Z0-9_]*);/g, (match, typeName, alias) => {
		addAlias(alias, normaliseTypeName(typeName));
	});
	let parts = cpp.split('\ntypedef struct ');
	parts.slice(1).forEach(cpp => {
		let cppName = cpp.split(' ', 1)[0];
		let name = cppName + "_t";
		if (types[name]) return; // already defined (probably custom)
		let struct = cpp.substr(cppName.length + 2).split("} " + name + ";", 1)[0];
		struct = struct.replace(/\/\/[^\n]*/g, '');
		let fields = struct.split(';').map(x => x.trim()).filter(x => x.length);

		let structFields = [];
		let structType = {
			type: null,
			compatible: true,
			wasmSize: 0,
			wasmAlign: 1
		};
		//types[name] = structType;
		types[name + ' *'] = pointerType;
		// Don't do these for now - see if they're used outside of method-style function pointers (which we will special-case)
		//types['struct ' + structName + ' *'] = types['const struct ' + structName + ' *'] = pointerType;
		//types['const ' + name + ' *'] = pointerType;

		fields.forEach(cpp => {
			function tryCustomType(fName) {
				let customType = customFields[name]?.[fName];
				if (customType) {
					let offset = customType.wasmSize;
					let align = customType.wasmAlign;
					structFields.push({
						name: fName,
						offset: offset,
						custom: customType
					});
					return true;
				}
			}

			let match;
			if (match = cpp.match(/^(.*[^a-zA-Z_])([a-zA-Z_][a-zA-Z0-9_]*)(\[([0-9]+)\])?$/)) {
				let fType = normaliseTypeName(match[1]), fName = match[2];
				let arrayCount = parseInt(match[4], 10) || null;
				if (tryCustomType(fName)) return;
				fType = fType.trim().replace(/\s+/g, ' ');
				if (!types[fType] && !types[fType + ' *']) {
					console.error(cpp);
					throw Error("Unknown type in struct " + name + ": " + fType);
//console.error("Unknown type in struct " + name + ": " + fType);
				}
				let fTypeObj = types[fType] || pointerType;
				let offset = structType.wasmSize;
				let align = fTypeObj.wasmAlign;
				while (offset%align) ++offset;
				structFields.push({
					name: fName,
					type: fType,
					offset: offset,
					arrayCount: arrayCount
				});
				structType.wasmSize += fTypeObj.wasmSize*(arrayCount || 1);
				structType.wasmAlign = Math.max(structType.wasmAlign, align);
			} else if (match = cpp.match(/^(.*)\s*\(CLAP_ABI \*([a-zA-Z_][a-zA-Z0-9_]*)\)\(([^\)]*)\)$/)) {
				let fReturn = normaliseTypeName(match[1]);
				let fName = match[2];
				if (tryCustomType(fName)) return;
				let fArgs = match[3].split(',').map(x => x.trim()).filter(x => x != 'void');
				
				fArgs = fArgs.map(arg => {
					// They all should end with an argument name, so we strip this out
					arg = arg.replace(/[a-zA-Z_][a-zA-Z0-9_]*$/, '');
					arg = normaliseTypeName(arg);
					if (!types[arg]) {
						console.error(cpp);
						throw Error("Unknown argument type in struct " + name + ": " + arg);
					}
					return arg;
				});

				if (fReturn == "void") {
					fReturn = null;
				}
				if (fReturn && !types[fReturn]) {
					console.error(cpp);
//					throw Error("Unknown return type in struct " + name + ": " + fReturn);
console.error("Unknown return type in struct " + name + ": " + fReturn);
				}

				let offset = structType.wasmSize;
				while (offset%wasmPointerSize) ++offset;
				structFields.push({
					name: fName,
					returnType: fReturn,
					argTypes: fArgs,
					offset: offset
				});
				structType.wasmSize += wasmPointerSize;
				structType.wasmAlign = Math.max(structType.wasmAlign, wasmPointerSize);
			} else {
				console.error(cpp);
				throw Error("Couldn't parse struct field in " + name);
			}
		});
		structFields.forEach(f => {
			if (!types[f.type]?.compatible) {
				structType.compatible = false;
			}
		});
		if (structType.compatible) {
			addDirectPointer(name);
		} else {
			code += `
// Translate: ${name} *
template<>
struct Wclap::Translate<${name} *> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, ${name} *nativeP) {`;
			structFields.forEach(field => {
				let wasmPointerValue = field.offset ? "(wasmP + " + field.offset + ")" : "wasmP";
				let arraySuffix = '', arrayIndent = '';
				if (field.arrayCount) {
					arrayIndent = '\t';
					code += `
		for (size_t a = 0; a < ${field.arrayCount}; ++a) {`;
					arraySuffix = '[a]';
					let wasmStride = types[field.type]?.wasmSize;
					if (wasmStride != 1) {
						wasmPointerValue = `(${wasmPointerValue} + a*${wasmStride})`;
					} else {
						wasmPointerValue = `(${wasmPointerValue} + a)`;
					}
				}
				if (types[field.type]?.compatible) {
					code += `
${arrayIndent}		nativeP->${field.name}${arraySuffix} = *(${field.type} *)translate->nativeInWasm(${wasmPointerValue});`;
				} else if (types[field.type + ' *']) {
					code += `
${arrayIndent}		Translate<${field.type} *>::assignWasmToNative(translate, ${wasmPointerValue}, &nativeP->${field.name}${arraySuffix});`;
				} else if (types[field.type]) {
					code += `
${arrayIndent}		nativeP->${field.name}${arraySuffix} = Translate<${field.type}>::wasmToNative(translate, *(uint32_t *)translate->nativeInWasm(${wasmPointerValue}));`;
				} else if (field.argTypes) {
					code += `
${arrayIndent}		BLARGH: ${field.returnType || 'void'} ${field.name}${arraySuffix}(${field.argTypes})`;
				} else {
					code += `
${arrayIndent}		BLARGH: ${field.type} ${field.name}${arraySuffix}`;
				}
				if (field.arrayCount) {
					code += `
		}`;
				}
			});
			code += `
		return nativeP;
	}
	// Copy to native memory and translate that
	static ${name} * wasmToNative(WclapTranslationScope *translate, WasmType wasmP) {
		if (!wasmP) return nullptr;
		auto *nativeP = (${name} *)translate->temporaryNativeBytes(sizeof(${name}), alignof(${name}));
		assignWasmToNative(translate, wasmP, nativeP);
		return nativeP;
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, ${name} *nativeP, WasmType wasmP) {`;
			structFields.forEach(field => {
				let wasmPointerValue = field.offset ? "(wasmP + " + field.offset + ")" : "wasmP";

				let arraySuffix = '', arrayIndent = '';
				if (field.arrayCount) {
					arrayIndent = '\t';
					code += `
		for (size_t a = 0; a < ${field.arrayCount}; ++a) {`;
					arraySuffix = '[a]';
					let wasmStride = types[field.type]?.wasmSize;
					if (wasmStride != 1) {
						wasmPointerValue = `(${wasmPointerValue} + a*${wasmStride})`;
					} else {
						wasmPointerValue = `(${wasmPointerValue} + a)`;
					}
				}

				if (types[field.type]?.compatible) {
					code += `
${arrayIndent}		*(${field.type} *)translate->nativeInWasm(${wasmPointerValue}) = nativeP->${field.name}${arraySuffix};`;
				} else if (types[field.type + ' *']) {
					code += `
${arrayIndent}		Translate<${field.type} *>::assignNativeToWasm(translate, &nativeP->${field.name}${arraySuffix}, ${wasmPointerValue});`;
				} else if (types[field.type]) {
					code += `
${arrayIndent}		*(${types[field.type].wasmType} *)translate->nativeInWasm(${wasmPointerValue}) = Translate<${field.type}>::nativeToWasm(translate, nativeP->${field.name}${arraySuffix});`;
				} else if (field.argTypes) {
					code += `
${arrayIndent}		BLARGH: ${field.returnType || 'void'} ${field.name}${arraySuffix}(${field.argTypes})`;
				} else {
					code += `
${arrayIndent}		BLARGH: ${field.type} ${field.name}${arraySuffix}`;
				}
				if (field.arrayCount) {
					code += `
		}`;
				}
			});
			code += `
		return wasmP;
	}
	// Make a copy in WASM memory, translate all the fields
	static WasmType nativeToWasm(WclapTranslationScope *translate, ${name} *nativeP) {
		if (!nativeP) return 0;
		uint32_t wasmP = translate->temporaryWasmBytes(${structType.wasmSize}, ${structType.wasmAlign});
		assignNativeToWasm(translate, nativeP, wasmP);
		return wasmP;
	}
};`;
		}
	});
}

addDirect("uint8_t", true, 1);
addDirect("uint16_t", true, 2);
addDirect("uint32_t", true, 4);
addDirect("uint64_t", true, 8);
addDirect("int8_t", true, 1);
addDirect("int16_t", true, 2);
addDirect("int32_t", true, 4);
addDirect("int64_t", true, 8);
addDirect("float", true, 4);
addDirect("double", true, 8);

addDirect("char", true, 1); // will be aliased
//addDirect("int", true, 4);

addDirect("bool", true, 1);
// Custom translation for this, because *we* know they're secretly arrays
addDirect("const char *", false, wasmPointerSize);

// We don't translate entry.h, because it contains .get_factory() (the one function which doesn't act as a method)
// entry.h

addObjectContextField("clap_host_t", "host_data");
addCustom("clap_host_t", "get_extension");
addObjectContextField("clap_istream_t", "ctx");
addCustom("clap_istream_t", "read");
addObjectContextField("clap_ostream_t", "ctx");
addCustom("clap_ostream_t", "write");
addCustom("clap_audio_buffer_t", "data32");
addCustom("clap_audio_buffer_t", "data64");
addCustom("clap_host_event_registry_t", "query");
addCustom("clap_event_param_value_t", "cookie");
addCustom("clap_event_param_mod_t", "cookie");
addCustom("clap_event_midi_sysex_t", "buffer");
addObjectContextField("clap_input_events_t", "ctx");
addObjectContextField("clap_output_events_t", "ctx");
addCustom("clap_plugin_descriptor_t", "features");
addObjectContextField("clap_plugin_t", "plugin_data");
addCustom("clap_plugin_t", "get_extension");
addObjectContextField("clap_preset_discovery_metadata_receiver_t", "receiver_data");
addObjectContextField("clap_preset_discovery_provider_t", "provider_data");
addCustom("clap_preset_discovery_provider_t", "get_extension");
addObjectContextField("clap_preset_discovery_indexer_t", "indexer_data");
addCustom("clap_preset_discovery_indexer_t", "get_extension");
addCustom("clap_audio_port_configuration_request_t", "port_details");
addObjectContextField("clap_context_menu_builder_t", "ctx");
addCustom("clap_context_menu_builder_t", "add_item");
addDirect("clap_window_t"); // There's a union in here which makes parsing non-trivial, so we handle it manually
addDirect("clap_window_t *"); // There's a union in here which makes parsing non-trivial, so we handle it manually
addCustom("clap_plugin_gui_t", "get_preferred_api");
addCustom("clap_plugin_gui_t", "get_size");
addCustom("clap_plugin_gui_t", "adjust_size");
addCustom("clap_param_info_t", "cookie");
addCustom("clap_plugin_params_t", "get_value");
addCustom("clap_plugin_params_t", "value_to_text");
addCustom("clap_plugin_params_t", "text_to_value");
// We're just not going to support this extension
addDirect("clap_plugin_posix_fd_support_t");
//addCustom("clap_plugin_posix_fd_support_t", "on_fd");
addDirect("clap_host_posix_fd_support_t");
//addCustom("clap_host_posix_fd_support_t", "register_fd");
//addCustom("clap_host_posix_fd_support_t", "modify_fd");
//addCustom("clap_host_posix_fd_support_t", "unregister_fd");
addCustom("clap_plugin_surround_t", "get_channel_map");
addCustom("clap_host_timer_support_t", "register_timer");

addFile("fixedpoint.h");
addFile("string-sizes.h");
addFile("id.h");
addFile("timestamp.h");
addFile("version.h");
addFile("color.h");
addFile("host.h");
addFile("stream.h");
addFile("audio-buffer.h");
addFile("events.h");
addFile("process.h");
addFile("plugin-features.h");
addFile("plugin.h");
addFile("universal-plugin-id.h");
addFile("factory/plugin-factory.h");
addFile("factory/preset-discovery.h");

addFile("ext/ambisonic.h");
addFile("ext/audio-ports.h");
addFile("ext/audio-ports-activation.h");
addFile("ext/audio-ports-config.h");
addFile("ext/configurable-audio-ports.h");
addFile("ext/context-menu.h");
addFile("ext/event-registry.h");
addFile("ext/gui.h");
addFile("ext/latency.h");
addFile("ext/log.h");
addFile("ext/note-name.h");
addFile("ext/note-ports.h");
addFile("ext/param-indication.h");
addFile("ext/params.h");
addFile("ext/posix-fd-support.h");
addFile("ext/preset-load.h");
addFile("ext/remote-controls.h");
addFile("ext/render.h");
addFile("ext/state-context.h");
addFile("ext/state.h");
addFile("ext/surround.h");
addFile("ext/tail.h");
addFile("ext/thread-check.h");
addFile("ext/thread-pool.h");
addFile("ext/timer-support.h");
addFile("ext/track-info.h");
addFile("ext/voice-info.h");
fs.writeFileSync(__dirname + "/source/translate-clap-api.h", code);
