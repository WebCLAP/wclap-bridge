const fs = require('fs');

const clapPrefix = __dirname + "/modules/clap/include/clap/";
const wasmPointerSize = 4;

let code = "/* Generated by translate-clap-api.js */\n";
let types = {};

function addDirectPointer(name) {
	code += `
// Translate: ${name} *
template<>
struct Wclap::Translate<${name} *> {
	using WasmType = uint32_t;
	// Translate the WASM pointer to a native one
	static ${name} * wasmToNative(Wasm *wasm, WasmType p) {
		if (!p) return nullptr;
		void *nativeInWasm = wasm_memory_data(wasm->memory) + p;
		return (${name} *)nativeInWasm;
	}
	// Make a temporary copy in the WASM memory, and point to that
	static WasmType nativeToWasm(Wasm *wasm, ${name} *v) {
		if (!v) return 0;
		uint32_t wasmP = wasm->temporaryWasmBytes(sizeof(${name}), alignof(${name}));
		void *nativeInWasm = wasm_memory_data(wasm->memory) + p;
		*(${name} *)nativeInWasm = *v;
		return wasmP;
	}
};`;
}
function addDirect(type, compatible, wasmSize, wasmAlign) {
	types[type] = {
		compatible: compatible,
		wasmSize: wasmSize,
		wasmAlign: wasmAlign || wasmSize
	};
}
function addFile(path) {
	let cpp = fs.readFileSync(clapPrefix + path, 'utf-8');
	let parts = cpp.split('\ntypedef struct ');
	parts.slice(1).forEach(cpp => {
		let structName = cpp.split(' ', 1)[0];
		let name = structName + "_t";
		if (types[name]) return; // already defined (probably custom)
		let struct = cpp.substr(name.length).split("} " + name + ";", 1)[0];
		struct = struct.replace(/\/\/[^\n]*/g, '');
		let fields = struct.split(';').map(x => x.trim()).filter(x => x.length);

		let structFields = [];
		let structType = {
			compatible: true,
			wasmSize: 0,
			wasmAlign: 1
		};
		types[name] = types['struct ' + structName] = structType;
		let pointerType = {
			compatible: false,
			wasmSize: wasmPointerSize,
			wasmAlign: wasmPointerSize
		}
		types[name + ' *'] = pointerType;
		// Don't do these for now - see if they're used outside of method-style function pointers (which we will special-case)
		//types['struct ' + structName + ' *'] = types['const struct ' + structName + ' *'] = pointerType;
		//types['const ' + name + ' *'] = pointerType;

		fields.forEach(cpp => {
			let match;
			if (match = cpp.match(/^(.*[^a-zA-Z_])([a-zA-Z_]+)$/)) {
				let fType = match[1], fName = match[2];
				fType = fType.trim().replace(/\s+/g, ' ');
				if (!types[fType]) {
					console.error(cpp);
					throw Error("Unknown type in struct " + name + ": " + fType);
				}
				let offset = structType.wasmSize;
				let align = types[fType].wasmAlign;
				while (offset%align) ++offset;
				structFields.push({
					name: fName,
					type: fType,
					offset: offset
				});
				structType.wasmSize += types[fType].wasmSize;
				structType.wasmAlign = Math.max(structType.wasmAlign, types[fType].wasmAlign);
			} else if (match = cpp.match(/^(.*)\s*\(CLAP_ABI \*([a-zA-Z_]+)\)\((.*)\)$/)) {
				let fReturn = match[1], fName = match[2], fArgs = match[3].split(',').map(x => x.trim()).filter(x => x != 'void');

				fArgs = fArgs.map(arg => {
					// They all should end with an argument name, so we strip this out
					arg = arg.replace(/[a-zA-Z_]+$/, '');
					if (!types[arg]) {
						console.error(cpp);
						throw Error("Unknown argument type in struct " + name + ": " + arg);
					}
					return arg;
				});

				if (fReturn == "void") {
					fReturn = null;
				} else if (/^(const )?void \*$/.test(fReturn)) {
					console.error(cpp);
					throw Error("void * returns can't be translated - they always get cast to something else, depending on the arguments");
				}
				console.log(fName + ": (" + fArgs + ") -> " + fReturn);
				if (fReturn && !types[fReturn]) {
					console.error(cpp);
					throw Error("Unknown return type in struct " + name + ": " + fReturn);
				}

				structFields.push({
					name: name,
					returnType: fReturn,
					argTypes: fArgs
				});
			} else {
				console.error(cpp);
				throw Error("Couldn't parse struct field in " + name);
			}
		});
		structFields.forEach(f => {
			if (!types[f.type].compatible) {
				structType.compatible = false;
			}
		});
		if (structType.compatible) {
			addDirectPointer(name);
			addDirectPointer('const ' + name);
		} else {
			code += `
// Translate: ${name} *
template<>
struct Wclap::Translate<${name} *> {
	using WasmType = uint32_t;
	// Make a temporary copy in native memory, and translate all the fields
	static ${name} * wasmToNative(Wasm *wasm, WasmType wasmP) {
		if (!wasmP) return nullptr;
		void *nativeInWasm = wasm_memory_data(wasm->memory) + p;
		auto *nativeP = (${name} *)wasm->temporaryNativeBytes(sizeof(${name}), alignof(${name}));`;
			structFields.forEach(field => {
				if (types[field.type].compatible) {
					code += `
		nativeP->${field.name} = *(${field.type} *)(nativeInWasm${field.offset ? " + " + field.offset : ""});`;
				} else {
					code += `
					BLARGH`;
				}
			});
			code += `
		return nativeP;
	}
	// Make a temporary copy in WASM memory, translate all the fields
	static WasmType nativeToWasm(Wasm *wasm, ${name} *nativeP) {
		if (!v) return 0;
		uint32_t p = wasm->temporaryWasmBytes(${structType.wasmSize}, ${structType.wasmAlign});
		void *nativeInWasm = wasm_memory_data(wasm->memory) + p;`;
			structFields.forEach(field => {
				if (types[field.type].compatible) {
					code += `
		*(${field.type} *)${field.offset ? "(nativeInWasm + " + field.offset + ")" : "nativeInWasm"} = nativeP->${field.name};`;
				} else {
					code += `
					BLARGH`;
				}
			});
			code += `
		return p;
	}
};`;
		}
	});
}

addDirect("uint8_t", true, 1);
addDirect("uint16_t", true, 2);
addDirect("uint32_t", true, 4);
addDirect("uint64_t", true, 8);
addDirect("int8_t", true, 1);
addDirect("int16_t", true, 2);
addDirect("int32_t", true, 4);
addDirect("int64_t", true, 8);
addDirect("float32_t", true, 4);
addDirect("float64_t", true, 8);
addDirect("bool", true, 1);
addDirect("const char *", false, wasmPointerSize);
addDirect("void *", false, wasmPointerSize);

//addDirect("clap_plugin_entry_t", false)

addFile("version.h");
//addFile("entry.h");
addFile("color.h");
addFile("host.h");

fs.writeFileSync(__dirname + "/source/translate-clap-api.h", code);
