const fs = require('fs');

const clapPrefix = __dirname + "/modules/clap/include/clap/";
const wasmPointerType = 'uint32_t';
const wasmPointerSize = 4;
const wasmPointerTypeCode = 'i';

let code = "/* Generated by translate-clap-api.js */\n";
let clapConstants = {
	CLAP_NAME_SIZE: 256,
	CLAP_PATH_SIZE: 1024,
	CLAP_REMOTE_CONTROLS_COUNT: 8
};
let customFields = {};
let objectContextFields = {}
let aliases = {};
let structTypes = {};
function normaliseTypeName(name) {
	name = name.replace(/\s+/g, ' ');
	for (let key in aliases) {
		name = (' ' + name + ' ').split(' ' + key + ' ').join(' ' + aliases[key] + ' ').trim();
	}
	name = name.replace(/\s*\*\s*/g, ' * ').replace(/\*\s*\*/g, '**').replace(/(^| )struct ([a-zA-Z_][a-zA-Z0-9_]*)/g, '$1$2_t').trim().replace(/(^| )const ([a-zA-Z_][a-zA-Z0-9_]*)_t/g, '$1$2_t');
	return name;
}
/* There are only 4 types in WASM (as far as APIs are concerned).  We assume functions have at most one return value, and use 'v' when there are none.
	v: void
	i: i32
	I: i64
	f: f32
	F: f64
*/
function wasmTypeCode(t) {
	if (t == null) return 'v';
	t = (' ' + t + ' ').replace(/ const /g, ' ');
	t = normaliseTypeName(t);
	if (/\*$/.test(t)) return 'i'; // pointer
	if (/^u?int32_t|bool$/.test(t)) return 'i';
	if (/^u?int64_t$/.test(t)) return 'I';
	if (/^float$/.test(t)) return 'f';
	if (/^double$/.test(t)) return 'F'
	throw Error('No code for type: ' + t);
}

const pointerType = {
	compatible: false,
	wasmType: wasmPointerType,
	wasmSize: wasmPointerSize,
	wasmAlign: wasmPointerSize
}

function addCustomField(name, field, typeObj) {
	customFields[name] = customFields[name] || {};
	customFields[name][field] = Object.assign(Object.assign({}, pointerType), typeObj || {});
}

function addAlias(aliasName, canonicalName) {
	aliases[aliasName] = canonicalName;
}

function addObjectContextField(name, field) {
	addCustomField(name, field, pointerType);
	objectContextFields[name] = field;
}

function addDirectPointer(name) {
	code += `
// Translate: ${name} *
template<>
struct Wclap::Translate<${name} *> {
	using WasmType = uint32_t;
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType p, ${name} *nativeP) {
		void *nativeInWasm = translate->nativeInWasm(p);
		*nativeP = *(${name} *)nativeInWasm;
	}
	static ${name} * wasmToNative(WclapTranslationScope *translate, WasmType wasmP) {
		if (!wasmP) return nullptr;
		void *nativeInWasm = translate->nativeInWasm(wasmP);
		return (${name} *)nativeInWasm;
	}
	static void assignNativeToWasm(WclapTranslationScope *translate, ${name} *nativeP, WasmType wasmP) {
		void *nativeInWasm = translate->nativeInWasm(wasmP);
		*(${name} *)nativeInWasm = *nativeP;
	}
	static WasmType nativeToWasm(WclapTranslationScope *translate, ${name} *nativeP) {
		if (!nativeP) return 0;
		uint32_t wasmP = translate->temporaryWasmBytes(sizeof(${name}), alignof(${name}));
		assignNativeToWasm(translate, nativeP, wasmP);
		return wasmP;
	}
};`;
}
// Types which can be copied by value between the two layers
function addDirect(type, wasmSize, wasmAlign, wasmType) {
	// they're not really structs, but the we flag them as "compatible" structs which means they get copied directly
	structTypes[type] = {
		compatible: true,
		wasmType: wasmType || (/\*$/.test(type) ? wasmPointerType : type),
		wasmSize: wasmSize,
		wasmAlign: wasmAlign || wasmSize
	};
	structTypes[normaliseTypeName(type + ' *')] = Object.assign({
		pointerToType: structTypes[type]
	}, pointerType);
}
// Types which we'll implement by hand in the translation layer
function addCustomDirect(type, wasmSize, wasmAlign, wasmType) {
	structTypes[type] = {
		wasmType: wasmType || (/\*$/.test(type) ? wasmPointerType : type),
		wasmSize: wasmSize,
		wasmAlign: wasmAlign || wasmSize
	};
	structTypes[normaliseTypeName(type + ' *')] = Object.assign({
		pointerToType: structTypes[type]
	}, pointerType);
}
function addFile(path) {
	let cpp = fs.readFileSync(clapPrefix + path, 'utf-8');
	for (let key in clapConstants) {
		cpp = cpp.split(key).join(clapConstants[key]);
	}
	
	cpp.replaceAll(/typedef\s+([^\{\};]+)\s+([a-zA-Z_][a-zA-Z0-9_]*);/g, (match, typeName, alias) => {
		addAlias(alias, normaliseTypeName(typeName));
	});
	let parts = cpp.split('\ntypedef struct ');
	parts.slice(1).forEach(cpp => {
		let cppName = cpp.split(' ', 1)[0];
		let name = cppName + "_t";
		if (structTypes[name]) return; // already defined (custom)
		let struct = cpp.substr(cppName.length + 2).split("} " + name + ";", 1)[0];
		struct = struct.replace(/\/\/[^\n]*/g, '');
		let fields = struct.split(';').map(x => x.trim()).filter(x => x.length);

		let structFields = [];
		let structType = {
			type: null,
			compatible: true,
			wasmSize: 0,
			wasmAlign: 1
		};
		structTypes[name] = structType;
		structTypes[name + ' *'] = Object.assign({pointerToType: structType}, pointerType);

		fields.forEach(cpp => {
			function tryCustomType(fName, arrayCount) {
				let customType = customFields[name]?.[fName];
				if (customType) {
					let offset = structType.wasmSize;
					let align = customType.wasmAlign;
					while (offset%align) ++offset;
					structFields.push({
						name: fName,
						offset: offset,
						custom: customType
					});
					structType.wasmSize += customType.wasmSize*(arrayCount || 1);
					structType.wasmAlign = Math.max(structType.wasmAlign, align);
					return true;
				}
			}

			let match;
			if (match = cpp.match(/^(.*[^a-zA-Z_])([a-zA-Z_][a-zA-Z0-9_]*)(\[([0-9]+)\])?$/)) {
				let fType = normaliseTypeName(match[1]), fName = match[2];
				let arrayCount = parseInt(match[4], 10) || null;
				if (tryCustomType(fName, arrayCount)) return;
				fType = fType.trim().replace(/\s+/g, ' ');
				if (!structTypes[fType]) { //  && !customTypes[fType + ' *']
					console.error(cpp);
					console.log(structTypes);
					throw Error("Unknown type in struct " + name + ": " + fType);
				}
				let fTypeObj = structTypes[fType];
				let offset = structType.wasmSize;
				let align = fTypeObj.wasmAlign;
				while (offset%align) ++offset;
				structFields.push({
					name: fName,
					type: fType,
					offset: offset,
					arrayCount: arrayCount
				});
				structType.wasmSize += fTypeObj.wasmSize*(arrayCount || 1);
				structType.wasmAlign = Math.max(structType.wasmAlign, align);
			} else if (match = cpp.match(/^(.*)\s*\(CLAP_ABI \*([a-zA-Z_][a-zA-Z0-9_]*)\)\(([^\)]*)\)$/)) {
				let fReturn = normaliseTypeName(match[1]);
				let fName = match[2];
				if (tryCustomType(fName)) return;
				let fArgs = match[3].split(',').map(x => x.trim()).filter(x => x != 'void');

				fArgs = fArgs.map(arg => {
					// They all should end with an argument name, so we strip this out
					arg = arg.replace(/[a-zA-Z_][a-zA-Z0-9_]*$/, '');
					arg = normaliseTypeName(arg);
					if (!structTypes[arg]) {
						console.error(cpp);
						throw Error("Unknown argument type in struct " + name + ": " + arg);
					}
					return arg;
				});

				if (fReturn == "void") {
					fReturn = null;
				}
				if (fReturn && !structTypes[fReturn]) {
					console.error(cpp);
//					throw Error("Unknown return type in struct " + name + ": " + fReturn);
console.error("Unknown return type in struct " + name + ": " + fReturn);
				}

				let wasmFnType = wasmTypeCode(fReturn) + fArgs.map(wasmTypeCode).join('');

				let offset = structType.wasmSize;
				while (offset%wasmPointerSize) ++offset;
				structFields.push({
					name: fName,
					wasmFnType: wasmFnType,
					returnType: fReturn,
					argTypes: fArgs,
					offset: offset
				});
				structType.wasmSize += wasmPointerSize;
				structType.wasmAlign = Math.max(structType.wasmAlign, wasmPointerSize);
			} else {
				console.error(cpp);
				throw Error("Couldn't parse struct field in " + name);
			}
		});
		structFields.forEach(f => {
			if (!structTypes[f.type]?.compatible) {
				structType.compatible = false;
			}
		});
		if (structType.compatible) {
			//addDirectPointer(name);
		} else {
			code += `
template<>
struct Wclap::TranslateStruct<${name}> {
	using WasmType = uint32_t;
	// translate all the fields
	static void assignWasmToNative(WclapTranslationScope *translate, WasmType wasmP, ${name} &native) {`;
			structFields.forEach(field => {
				let wasmPointerArg = field.offset ? "wasmP + " + field.offset : "wasmP";
				let arraySuffix = '', arrayIndent = '';
				if (field.arrayCount) {
					if (!structTypes[field.type]) {
						throw Error("Array of unknown type: " + field.type);
					}
					arrayIndent = '\t';
					code += `
		for (size_t a = 0; a < ${field.arrayCount}; ++a) {`;
					arraySuffix = '[a]';
					let wasmStride = structTypes[field.type].wasmSize;
					if (wasmStride != 1) {
						wasmPointerArg += ` + a*${wasmStride}`
					} else {
						wasmPointerArg += ` + a`;
					}
				}
				//let wasmPointerValue = /\s/.test(wasmPointerArg) ? `(${wasmPointerArg})` : wasmPointerArg;

				if (structTypes[field.type]?.compatible) {
					code += `
${arrayIndent}		translate->assignWasmToNativeDirect<${field.type}>(${wasmPointerArg}, native.${field.name}${arraySuffix});`;
				} else if (structTypes[field.type]?.pointerToType?.compatible) {
					code += `
${arrayIndent}		translate->assignWasmToNativeDirectPointer<${field.type}>(${wasmPointerArg}, native.${field.name}${arraySuffix});`;
				} else if (field.wasmFnType) {
					code += `
${arrayIndent}		translate->assignWasmToNative_${field.wasmFnType}(${wasmPointerArg}, native.${field.name}${arraySuffix}); // ${field.returnType || 'void'} ${field.name}${arraySuffix}()`;
				} else if (customFields[name]?.[field.name]) {
					code += `
${arrayIndent}		translate->assignWasmToNative_${name}_${field.name}(${wasmPointerArg}, native.${field.name}${arraySuffix});`;
				} else {
					if (!structTypes[field.type]) {
						throw Error("Translating field of unknown type: " + field.type);
					}
					code += `
${arrayIndent}		translate->assignWasmToNative<${field.type}>(${wasmPointerArg}, native.${field.name}${arraySuffix});`;
				}
				if (field.arrayCount) {
					code += `
		}`;
				}
			});
			code += `
	}
	// translate all the fields
	static void assignNativeToWasm(WclapTranslationScope *translate, const ${name} &native, WasmType wasmP) {`;
			structFields.forEach(field => {
				let wasmPointerArg = field.offset ? "wasmP + " + field.offset : "wasmP";
				let arraySuffix = '', arrayIndent = '';
				if (field.arrayCount) {
					if (!structTypes[field.type]) {
						throw Error("Array of unknown type: " + field.type);
					}
					arrayIndent = '\t';
					code += `
		for (size_t a = 0; a < ${field.arrayCount}; ++a) {`;
					arraySuffix = '[a]';
					let wasmStride = structTypes[field.type].wasmSize;
					if (wasmStride != 1) {
						wasmPointerArg += ` + a*${wasmStride}`
					} else {
						wasmPointerArg += ` + a`;
					}
				}

				if (structTypes[field.type]?.compatible) {
					code += `
${arrayIndent}		translate->assignNativeToWasmDirect<${field.type}>(native.${field.name}${arraySuffix}, ${wasmPointerArg});`;
				} else if (structTypes[field.type]?.pointerToType?.compatible) {
					code += `
${arrayIndent}		translate->assignNativeToWasmDirectPointer<${field.type}>(native.${field.name}${arraySuffix}, ${wasmPointerArg});`;
				} else if (field.wasmFnType) {
					code += `
${arrayIndent}		translate->assignNativeToWasm_${field.wasmFnType}(native.${field.name}${arraySuffix}, ${wasmPointerArg}); // ${field.returnType || 'void'} ${field.name}${arraySuffix}(${field.argTypes})`;
				} else if (customFields[name]?.[field.name]) {
					code += `
${arrayIndent}		translate->assignNativeToWasm_${name}_${field.name}(native.${field.name}${arraySuffix}, ${wasmPointerArg});`;
				} else {
					if (!structTypes[field.type]) {
						throw Error("Translating field of unknown type: " + field.type);
					}
					code += `
${arrayIndent}		translate->assignNativeToWasm<${structTypes[field.type].wasmType}>(native.${field.name}${arraySuffix}, ${wasmPointerArg});`;
				}
				if (field.arrayCount) {
					code += `
		}`;
				}
			});
			code += `
	}
};`;
		}
	});
}

addDirect("uint8_t", 1);
addDirect("uint16_t", 2);
addDirect("uint32_t", 4);
addDirect("uint64_t", 8);
addDirect("int8_t", 1);
addDirect("int16_t", 2);
addDirect("int32_t", 4);
addDirect("int64_t", 8);
addDirect("float", 4);
addDirect("double", 8);
addDirect("bool", 1);

addDirect("char", 1); // will be aliased, but we specifically want to catch `const char *` later
// Custom translation for this, because *we* know they're secretly strings
addCustomDirect("const char *", false, wasmPointerSize);

// We don't translate entry.h, because it contains .get_factory(), the one function which doesn't act as a method
// entry.h

addObjectContextField("clap_host_t", "host_data");
addCustomField("clap_host_t", "get_extension");
addObjectContextField("clap_istream_t", "ctx");
addCustomField("clap_istream_t", "read");
addObjectContextField("clap_ostream_t", "ctx");
addCustomField("clap_ostream_t", "write");
addCustomField("clap_audio_buffer_t", "data32");
addCustomField("clap_audio_buffer_t", "data64");
addCustomField("clap_host_event_registry_t", "query");
addCustomField("clap_event_param_value_t", "cookie");
addCustomField("clap_event_param_mod_t", "cookie");
addCustomField("clap_event_midi_sysex_t", "buffer");
addObjectContextField("clap_input_events_t", "ctx");
addObjectContextField("clap_output_events_t", "ctx");
addCustomField("clap_plugin_descriptor_t", "features");
addObjectContextField("clap_plugin_t", "plugin_data");
addCustomField("clap_plugin_t", "get_extension");
addObjectContextField("clap_preset_discovery_metadata_receiver_t", "receiver_data");
addObjectContextField("clap_preset_discovery_provider_t", "provider_data");
addCustomField("clap_preset_discovery_provider_t", "get_extension");
addObjectContextField("clap_preset_discovery_indexer_t", "indexer_data");
addCustomField("clap_preset_discovery_indexer_t", "get_extension");
addCustomField("clap_audio_port_configuration_request_t", "port_details");
addObjectContextField("clap_context_menu_builder_t", "ctx");
addCustomField("clap_context_menu_builder_t", "add_item");
addCustomDirect("clap_window_t"); // There's a union in here which makes parsing non-trivial, so we handle it manually
addCustomField("clap_plugin_gui_t", "get_preferred_api");
addCustomField("clap_plugin_gui_t", "get_size");
addCustomField("clap_plugin_gui_t", "adjust_size");
addCustomField("clap_param_info_t", "cookie");
addCustomField("clap_plugin_params_t", "get_value");
addCustomField("clap_plugin_params_t", "value_to_text");
addCustomField("clap_plugin_params_t", "text_to_value");
addCustomField("clap_plugin_surround_t", "get_channel_map");
addCustomField("clap_host_timer_support_t", "register_timer");

addFile("fixedpoint.h");
addFile("string-sizes.h");
addFile("id.h");
addFile("timestamp.h");
addFile("version.h");
addFile("color.h");
addFile("host.h");
addFile("stream.h");
addFile("audio-buffer.h");
addFile("events.h");
addFile("process.h");
addFile("plugin-features.h");
addFile("plugin.h");
addFile("universal-plugin-id.h");
addFile("factory/plugin-factory.h");
addFile("factory/preset-discovery.h");

addFile("ext/ambisonic.h");
addFile("ext/audio-ports.h");
addFile("ext/audio-ports-activation.h");
addFile("ext/audio-ports-config.h");
addFile("ext/configurable-audio-ports.h");
addFile("ext/context-menu.h");
addFile("ext/event-registry.h");
addFile("ext/gui.h");
addFile("ext/latency.h");
addFile("ext/log.h");
addFile("ext/note-name.h");
addFile("ext/note-ports.h");
addFile("ext/param-indication.h");
addFile("ext/params.h");
// We're just not going to support this extension for now
//addFile("ext/posix-fd-support.h");
addFile("ext/preset-load.h");
addFile("ext/remote-controls.h");
addFile("ext/render.h");
addFile("ext/state-context.h");
addFile("ext/state.h");
addFile("ext/surround.h");
addFile("ext/tail.h");
addFile("ext/thread-check.h");
addFile("ext/thread-pool.h");
addFile("ext/timer-support.h");
addFile("ext/track-info.h");
addFile("ext/voice-info.h");
fs.writeFileSync(__dirname + "/source/translate-clap-api.h", code);
