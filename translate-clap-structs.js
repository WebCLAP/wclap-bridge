const fs = require('fs');

const clapPrefix = __dirname + "/modules/clap/include/clap/";

function translate(use64) {
	const bits = use64 ? 64 : 32;
	const wasmPointerType = (use64 ? 'uint64_t' : 'uint32_t');
	const wasmPointerSize = (use64 ? 8 : 4);
	const wasmPointerTypeCode = (use64 ? 'L' : 'I');
	const translatorClass = `WclapTranslator`;
	const scopeClass = `WclapTranslationScope`;

	let code = `/* Generated by translate-clap-structs.js */
namespace wclap { namespace wclap${bits} {`;
	let clapConstants = {
		CLAP_NAME_SIZE: 256,
		CLAP_PATH_SIZE: 1024,
		CLAP_REMOTE_CONTROLS_COUNT: 8
	};
	let customFields = {};
	let aliases = {};
	let structTypes = {};
	function getType(name) {
		//name = normaliseTypeName(name);
		let obj = name.endsWith('*') ? pointerType : structTypes[name];
		if (!obj) throw Error("unknown type: " + name);
		return obj;
	}
	function normaliseTypeName(name) {
		name = name.replace(/\s+/g, ' ');
		for (let key in aliases) {
			name = (' ' + name + ' ').split(' ' + key + ' ').join(' ' + aliases[key] + ' ').trim();
		}
		name = name.replace(/\s*\*\s*/g, ' * ').replace(/\*\s*\*/g, '**').replace(/(^| )struct ([a-zA-Z_][a-zA-Z0-9_]*)/g, '$1$2_t').trim().replace(/(^| )const ([a-zA-Z_][a-zA-Z0-9_]*)_t/g, '$1$2_t');
		return name;
	}
	/* There are only 4 types in WASM (as far as APIs are concerned).  We assume functions have at most one return value, and use 'v' when there are none.
		v: void
		I: i32
		L: i64
		F: f32
		D: f64
	*/
	function wasmTypeCode(t) {
		if (t == null) return 'v';
		t = (' ' + t + ' ').replace(/ const /g, ' ');
		t = normaliseTypeName(t);
		if (/\*$/.test(t)) return wasmPointerTypeCode; // pointer
		if (/^u?int32_t|bool$/.test(t)) return 'I';
		if (/^u?int64_t$/.test(t)) return 'L';
		if (/^float$/.test(t)) return 'F';
		if (/^double$/.test(t)) return 'D'
		throw Error('No code for type: ' + t);
	}

	const pointerType = {
		compatible: false,
		wasmType: wasmPointerType,
		wasmSize: wasmPointerSize,
		wasmAlign: wasmPointerSize
	}

	function addAlias(aliasName, canonicalName) {
		aliases[aliasName] = canonicalName;
	}
	
	// Types which can be copied by value between the two layers
	function addDirect(type, wasmSize, wasmAlign, wasmType) {
		// they're not really structs, but the we flag them as "compatible" structs which means they get copied directly
		structTypes[type] = {
			compatible: true,
			wasmType: wasmType || (/\*$/.test(type) ? wasmPointerType : type),
			wasmSize: wasmSize,
			wasmAlign: wasmAlign || wasmSize
		};
	}
	
	function addFile(path) {
		let cpp = fs.readFileSync(clapPrefix + path, 'utf-8');
		for (let key in clapConstants) {
			cpp = cpp.split(key).join(clapConstants[key]);
		}
		
		cpp.replaceAll(/typedef\s+([^\{\};]+)\s+([a-zA-Z_][a-zA-Z0-9_]*);/g, (match, typeName, alias) => {
			addAlias(alias, normaliseTypeName(typeName));
		});
		let parts = cpp.split('\ntypedef struct ');
		parts.slice(1).forEach(cpp => {
			let cppName = cpp.split(' ', 1)[0];
			let name = cppName + "_t";
			if (structTypes[name]) throw Error("double definition: " + name);
			let struct = cpp.substr(cppName.length + 2).split("} " + name + ";", 1)[0];
			struct = struct.replace(/\/\/[^\n]*/g, '');
			let fields = struct.split(';').map(x => x.trim()).filter(x => x.length);

			let structFields = [];
			let structType = {
				type: null,
				compatible: true,
				wasmSize: 0,
				wasmAlign: 1
			};
			structTypes[name] = structType;

			fields.forEach(cpp => {
				let match;
				if (match = cpp.match(/^(.*[^a-zA-Z_])([a-zA-Z_][a-zA-Z0-9_]*)(\[([0-9]+)\])?$/)) {
					let fType = normaliseTypeName(match[1]), fName = match[2];
					let arrayCount = parseInt(match[4], 10) || null;
					fType = fType.trim().replace(/\s+/g, ' ');

					let fTypeObj = getType(fType);

					let offset = structType.wasmSize;
					let align = fTypeObj.wasmAlign;
					while (offset%align) ++offset;
					structFields.push({
						name: fName,
						type: fType,
						offset: offset,
						arrayCount: arrayCount
					});
					structType.wasmSize += fTypeObj.wasmSize*(arrayCount || 1);
					structType.wasmAlign = Math.max(structType.wasmAlign, align);
				} else if (match = cpp.match(/^(.*)\s*\(CLAP_ABI \*([a-zA-Z_][a-zA-Z0-9_]*)\)\(([^\)]*)\)$/)) {
					let fReturn = normaliseTypeName(match[1]);
					let fName = match[2];
					let fArgs = match[3].split(',').map(x => x.trim()).filter(x => x != 'void');

					let fArgNames = [];
					fArgs = fArgs.map((arg, argIndex) => {
						// They all should end with an argument name, so we strip this out
						let argName = (arg.match(/[a-zA-Z_][a-zA-Z0-9_]*$/) || ['arg' + argIndex])[0];
						fArgNames.push(argName);
						arg = arg.replace(/[a-zA-Z_][a-zA-Z0-9_]*$/, '');
						arg = normaliseTypeName(arg);

						getType(arg); // check it exists
						return arg;
					});

					if (fReturn == "void") {
						fReturn = null;
					} else {
						getType(fReturn); // check it exists
					}
					
					console.log(name, fName, fReturn, fArgs);

					let offset = structType.wasmSize;
					while (offset%wasmPointerSize) ++offset;
					structFields.push({
						name: fName,
						type: '()*', /* function pointer */
						returnType: fReturn,
						argNames: fArgNames,
						argTypes: fArgs,
						offset: offset
					});
					structType.wasmSize += wasmPointerSize;
					structType.wasmAlign = Math.max(structType.wasmAlign, wasmPointerSize);
				} else {
					console.error(cpp);
					throw Error("Couldn't parse struct field in " + name);
				}
			});
			
			// Only compatible if all its fields are compatible
			structFields.forEach(f => {
				if (!structTypes[f.type]?.compatible) {
					structType.compatible = false;
				}
			});
			
			let wclapClass = `w${name}`.replace(/_t$/, '');

			if (structType.compatible) {
				code += `

using ${wclapClass} = ${name};`;

			} else {
				let nativeType = `${name}`;
				if (structType.calledAsObject && !structType.object) {
					nativeType = `WclapLifetimeStruct<${name}>`;
				}
				code += `

struct ${wclapClass} {
	${wclapClass}(unsigned char * pointerInWasm) : pointerInWasm(pointerInWasm) {}
`;
				structFields.forEach(field => {
					let fieldType = getType(field.type);

					let wasmPointerArg = field.offset ? "pointerInWasm + " + field.offset : "pointerInWasm";
					if (field.arrayCount) {
						let wasmStride = fieldType.wasmSize;
						if (wasmStride != 1) {
							wasmPointerArg += ` + index*${wasmStride}`
						} else {
							wasmPointerArg += ` + index`;
						}
					}
					if (/\s/.test(wasmPointerArg)) wasmPointerArg = `(${wasmPointerArg})`;
					if (fieldType.compatible) {
						code += `
	${field.type} & ${field.name}(${field.arrayCount ? 'size_t index' : ''}) {
		return *(${field.type} *)${wasmPointerArg};
	}`;
					} else {
						let resultType = /\*$/.test(field.type) ? "WasmP" : `Wclap${bits}_${field.type}`;
						code += `
	${resultType} & ${field.name}(${field.arrayCount ? 'size_t index' : ''}) {
		return *(${resultType} *)${wasmPointerArg};
	}`;
					}
				});
				code += `
private:
	unsigned char * pointerInWasm;
};`;
			}
		});
	}

	addDirect("uint8_t", 1);
	addDirect("uint16_t", 2);
	addDirect("uint32_t", 4);
	addDirect("uint64_t", 8);
	addDirect("int8_t", 1);
	addDirect("int16_t", 2);
	addDirect("int32_t", 4);
	addDirect("int64_t", 8);
	addDirect("float", 4);
	addDirect("double", 8);
	addDirect("bool", 1);
	addDirect("char", 1); // will be aliased, but we specifically want to catch `const char *` later

	addFile("version.h");
	addFile("process.h");
	addFile("plugin.h");
	addFile("factory/plugin-factory.h");
	addFile("entry.h");
	/*
	addFile("fixedpoint.h");
	addFile("string-sizes.h");
	addFile("id.h");
	addFile("timestamp.h");
	addFile("color.h");
	addFile("host.h");
	addFile("stream.h");
	addFile("audio-buffer.h");
	addFile("events.h");
	addFile("plugin-features.h");
	addFile("universal-plugin-id.h");
	addFile("factory/preset-discovery.h");

	addFile("ext/ambisonic.h");
	addFile("ext/audio-ports.h");
	addFile("ext/audio-ports-activation.h");
	addFile("ext/audio-ports-config.h");
	addFile("ext/configurable-audio-ports.h");
	addFile("ext/context-menu.h");
	addFile("ext/event-registry.h");
	addFile("ext/gui.h");
	addFile("ext/latency.h");
	addFile("ext/log.h");
	addFile("ext/note-name.h");
	addFile("ext/note-ports.h");
	addFile("ext/param-indication.h");
	addFile("ext/params.h");
	addFile("ext/posix-fd-support.h");
	addFile("ext/preset-load.h");
	addFile("ext/remote-controls.h");
	addFile("ext/render.h");
	addFile("ext/state-context.h");
	addFile("ext/state.h");
	addFile("ext/surround.h");
	addFile("ext/tail.h");
	addFile("ext/thread-check.h");
	addFile("ext/thread-pool.h");
	addFile("ext/timer-support.h");
	addFile("ext/track-info.h");
	addFile("ext/voice-info.h");
	//*/

	code += `
}} // namespace
`;
	fs.writeFileSync(__dirname + `/source/wclap${bits}/translate-clap-structs.generated.h`, code);
}

translate(false);
translate(true);
