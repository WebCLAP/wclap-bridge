"use strict"
const fs = require('fs');

const clapPrefix = __dirname + "/modules/clap/include/clap/";

let classIdEnum = {};

function translate(use64) {
	const bits = use64 ? 64 : 32;
	const wasmPointerType = (use64 ? 'uint64_t' : 'uint32_t');
	const wasmPointerSize = (use64 ? 8 : 4);
	const wasmPointerTypeCode = (use64 ? 'L' : 'I');
	const translatorClass = `WclapTranslator`;
	
	let code = `/* Generated by translate-clap-structs.js */
#pragma once
namespace wclap { namespace wclap${bits} {`;

	let clapConstants = {
		CLAP_NAME_SIZE: 256,
		CLAP_PATH_SIZE: 1024,
		CLAP_REMOTE_CONTROLS_COUNT: 8
	};
	let aliases = {};
	let structTypes = {};
	let skipType = {};
	function getType(name) {
		name = normaliseTypeName(name);
		let obj = name.endsWith('*') ? pointerType : structTypes[name];
		if (!obj) throw Error("unknown type: " + name);
		return obj;
	}
	function getWasmType(name) {
		if (name == 'bool') return 'uint32_t';
		name = normaliseTypeName(name);
		if (/\*$/.test(name)) return 'WasmP';
		if (!structTypes[name].wasmType) throw Error("not a plain WASM type: " + name);
		return structTypes[name].wasmType;
	}
	function wasmTypeCode(t) {
		if (t == null) return 'V';
		t = (' ' + t + ' ').replace(/ const /g, ' ');
		t = normaliseTypeName(t);
		if (/\*$/.test(t)) return 'P'; // pointer
		if (/^u?int32_t|bool$/.test(t)) return 'I';
		if (/^u?int64_t$/.test(t)) return 'L';
		if (/^float$/.test(t)) return 'F';
		if (/^double$/.test(t)) return 'D'
		throw Error('No code for type: ' + t);
	}
	function normaliseTypeName(name) {
		name = name.replace(/\s+/g, ' ');
		for (let key in aliases) {
			name = (' ' + name + ' ').split(' ' + key + ' ').join(' ' + aliases[key] + ' ').trim();
		}
		name = name.replace(/\s*\*\s*/g, ' * ').replace(/\*\s*\*/g, '**').replace(/(^| )struct ([a-zA-Z_][a-zA-Z0-9_]*)/g, '$1$2_t').trim().replace(/(^| )const ([a-zA-Z_][a-zA-Z0-9_]*)_t/g, '$1$2_t');
		return name;
	}

	const pointerType = {
		compatible: false,
		wasmType: wasmPointerType,
		wasmSize: wasmPointerSize,
		wasmAlign: wasmPointerSize
	}

	function addAlias(aliasName, canonicalName) {
		aliases[aliasName] = canonicalName;
	}
	
	function doNotTranslate(type) {
		skipType[type] = true;
	}
	
	// Types which can be copied by value between the two layers
	function addDirect(type, wasmSize, wasmAlign, wasmType) {
		// they're not really structs, but the we flag them as "compatible" structs which means they get copied directly
		structTypes[type] = {
			compatible: true,
			wasmType: wasmType || (/\*$/.test(type) ? wasmPointerType : type),
			wasmSize: wasmSize,
			wasmAlign: wasmAlign || wasmSize
		};
	}
	
	function addFile(path) {
		let cpp = fs.readFileSync(clapPrefix + path, 'utf-8');
		for (let key in clapConstants) {
			cpp = cpp.split(key).join(clapConstants[key]);
		}
		
		cpp.replaceAll(/typedef\s+([^\{\};]+)\s+([a-zA-Z_][a-zA-Z0-9_]*);/g, (match, typeName, alias) => {
			addAlias(alias, normaliseTypeName(typeName));
		});
		let parts = cpp.split('\ntypedef struct ');
		parts.slice(1).forEach(cpp => {
			let cppName = cpp.split(' ', 1)[0];
			let isNativeOnly = /^clap_host(_|$)/.test(cppName) || /^clap_(input|output)_events(_t)?/.test(cppName);
			let isWasmOnly = /^clap_plugin(_|$)/.test(cppName);
			let noTranslation = false;
			if (cppName == 'clap_plugin_entry') noTranslation = true;

			let name = cppName + "_t";
			if (skipType[cppName]) return;
			if (structTypes[name]) throw Error("double definition: " + name);
			let struct = cpp.substr(cppName.length + 2).split("} " + name + ";", 1)[0];
			struct = struct.replace(/\/\/[^\n]*/g, '');
			let fields = struct.split(';').map(x => x.trim()).filter(x => x.length);

			let structFields = [];
			let structType = {
				type: null,
				compatible: true,
				wasmSize: 0,
				wasmAlign: 1
			};
			structTypes[name] = structType;

			fields.forEach(cpp => {
				let match;
				if (match = cpp.match(/^(.*[^a-zA-Z_])([a-zA-Z_][a-zA-Z0-9_]*)(\[([0-9]+)\])?$/)) {
					let fType = normaliseTypeName(match[1]), fName = match[2];
					let arrayCount = parseInt(match[4], 10) || null;
					fType = fType.trim().replace(/\s+/g, ' ');

					let fTypeObj = getType(fType);

					let offset = structType.wasmSize;
					let align = fTypeObj.wasmAlign;
					while (offset%align) ++offset;
					structFields.push({
						name: fName,
						type: fType,
						offset: offset,
						arrayCount: arrayCount
					});
					structType.wasmSize += fTypeObj.wasmSize*(arrayCount || 1);
					structType.wasmAlign = Math.max(structType.wasmAlign, align);
				} else if (match = cpp.match(/^(.*)\s*\(CLAP_ABI \*([a-zA-Z_][a-zA-Z0-9_]*)\)\(([^\)]*)\)$/)) {
					let fReturn = match[1];
					let fName = match[2];
					let fArgs = match[3].split(',').map(x => x.trim()).filter(x => x != 'void');

					let fArgNames = [];
					fArgs = fArgs.map((arg, argIndex) => {
						// They all should end with an argument name, so we strip this out
						let argName = (arg.match(/[a-zA-Z_][a-zA-Z0-9_]*$/) || ['arg' + argIndex])[0];
						fArgNames.push(argName);
						arg = arg.replace(/[a-zA-Z_][a-zA-Z0-9_]*$/, '');
						//arg = normaliseTypeName(arg);

						getType(arg); // check it exists
						return arg.replace(/\s+/g, ' ');
					});

					if (fReturn == "void") {
						fReturn = null;
					} else {
						getType(fReturn); // check it exists
					}
					
					let offset = structType.wasmSize;
					while (offset%wasmPointerSize) ++offset;
					structFields.push({
						name: fName,
						type: '()*', /* function pointer */
						returnType: fReturn,
						argNames: fArgNames,
						argTypes: fArgs,
						offset: offset
					});
					structType.wasmSize += wasmPointerSize;
					structType.wasmAlign = Math.max(structType.wasmAlign, wasmPointerSize);
				} else {
					console.error(cpp);
					throw Error("Couldn't parse struct field in " + name);
				}
			});
			while (structType.wasmSize%structType.wasmAlign) ++structType.wasmSize;
			
			// Only compatible if all its fields are compatible
			structFields.forEach(f => {
				if (!structTypes[f.type]?.compatible) {
					structType.compatible = false;
				}
			});
			
			let wclapClass = `w${name}`.replace(/_t$/, '');
			classIdEnum[name.replace(/_t$/, '')] = true;
			
			if (structType.compatible) {
				code += `

using ${wclapClass} = ${name};`;

			} else {
				let nativeType = `${name}`;
				code += `

struct ${wclapClass} {
	${wclapClass}(unsigned char *pointerInWasm) : pointerInWasm(pointerInWasm) {}
	
	static constexpr size_t wasmAlign = ${structType.wasmAlign};
	static constexpr size_t wasmSize = ${structType.wasmSize};
	
	operator bool() const {
		return pointerInWasm;
	}
`;
				structFields.forEach(field => {
					let fieldType = getType(field.type);

					let wasmPointerArg = field.offset ? "pointerInWasm + " + field.offset : "pointerInWasm";
					if (field.arrayCount) {
						let wasmStride = fieldType.wasmSize;
						if (wasmStride != 1) {
							wasmPointerArg += ` + index*${wasmStride}`
						} else {
							wasmPointerArg += ` + index`;
						}
					}
					if (/\s/.test(wasmPointerArg)) wasmPointerArg = `(${wasmPointerArg})`;
					if (fieldType.compatible) {
						code += `
	${field.type} & ${field.name}(${field.arrayCount ? 'size_t index' : ''}) {
		return *(${field.type} *)${wasmPointerArg};
	}`;
					} else {
						let resultType = /\*$/.test(field.type) ? "WasmP" : `Wclap${bits}_${field.type}`;
						code += `
	${resultType} & ${field.name}(${field.arrayCount ? 'size_t index' : ''}) {
		return *(${resultType} *)${wasmPointerArg};
	}`;
					}
				});

				let isFirstMethod = true;
				structFields.forEach(field => {
					if (isNativeOnly || noTranslation) return;

					let fieldType = getType(field.type);
					if (field.argTypes) {
						if (isFirstMethod) {
							code += '\n';
							isFirstMethod = false;
						}
						let argsCode = '';
						let needsWasmArena = false;
						let needsNativeArena = field.returnType && !getType(field.returnType).compatible;
						for (let i = 0; i < field.argTypes.length; ++i) {
							if (i > 0) argsCode += ', ';
							argsCode += field.argTypes[i];
							if (!/\*$/.test(field.argTypes[i])) code += ' ';
							argsCode += field.argNames[i];
							if (i > 0 && !getType(field.argTypes[i]).compatible) {
								needsWasmArena = true;
							}
						}
						// Our context should be able to look up the following two objects
						// the struct in which this method is defined (which we take the actual function pointer from)
						let contextMethodGroupField = "wasmMap." + name.replace(/_t$/, '').replace(/^clap_/, '');
						// and the object pointer itself
						let contextObjectField = field.argTypes[0] || "unknown";
						contextObjectField = contextObjectField.replace(/\s*\**$/, '');
						contextObjectField = contextObjectField.replace(/^.*\s+/, '');
						contextObjectField = contextObjectField.replace(/_t$/, '').replace(/^clap_/, '');
						contextObjectField = "wasmMap." + contextObjectField;
						
						code += `
	template<bool realtime=false>
	static ${field.returnType || 'void'} nativeProxy_${field.name}(${argsCode}) {
		auto &context = getNativeProxyContext(${field.argNames[0] || ('(' + name + ' *)nullptr')});
		auto scoped = context.lock(realtime);
		WasmP wasmFn = scoped.view<${wclapClass}>(context.${contextMethodGroupField}).${field.name}();
		`;
						if (needsWasmArena || needsNativeArena) {
							code += `
		auto resetW = scoped.arenas.scopedWasmReset();
		`;
						}
						for (let i = 1; i < field.argTypes.length; ++i) {
							let argType = getType(field.argTypes[i]);
							if (!argType.compatible) {
								code += `
		${getWasmType(field.argTypes[i])} wasm_${field.argNames[i]};`;
								if (/^const\s/.test(field.argTypes[i])) {
									code += `
		nativeToWasm(scoped, ${field.argNames[i]}, wasm_${field.argNames[i]});`;
								} else {
									code += `
		scoped.create<wclap_process>(wasm_${field.argNames[i]});`
								}
							}
						}
						if (field.returnType) {
							code += `
		${getWasmType(field.returnType)} wasmResult = scoped.thread.callWasm_${wasmTypeCode(field.returnType)}(wasmFn, context.${contextObjectField}`;
						} else {
							code += `
		scoped.thread.callWasm_V(wasmFn, context.${contextObjectField}`;
						}
						for (let i = 1; i < field.argTypes.length; ++i) {
							let argType = getType(field.argTypes[i]);
							if (argType.compatible) {
								code += `, ${field.argNames[i]}`;
							} else {
								code += `, wasm_${field.argNames[i]}`;
							}
						}
						code += `);`;

						for (let i = 1; i < field.argTypes.length; ++i) {
							let argType = getType(field.argTypes[i]);
							if (!argType.compatible) {
								if (!/^const\s/.test(field.argTypes[i])) {
									code += `
		wasmToNative(scoped, wasm_${field.argNames[i]}, (const ${field.argTypes[i]})${field.argNames[i]});`;
								}
							}
						}

						if (field.returnType) {
							if (getType(field.returnType).compatible) {
								code += `
		return wasmResult;`;
							} else {
								code += `

		auto resetN = scoped.arenas.scopedNativeReset();
		${field.returnType + (/\*$/.test(field.returnType) ? '' : ' ')}nativeResult;
		wasmToNative(scoped, wasmResult, nativeResult);
		return nativeResult;`;
							}
						}
						code += `
	}`;
					}
				});
				
				// Generate WASM -> native translation method
				code += `
private:
	unsigned char *pointerInWasm;
};`;
				if (!isNativeOnly && !noTranslation) {
					let methods = structFields.filter(field => field.argTypes);
					if (methods.length && methods.length == structFields.length) {
						code += `

template<bool realtime>
${name.replace(/_t$/, '')} * generated_nativeProxy_${name.replace(/_t$/, '')}() {
	static ${name.replace(/_t$/, '')} proxy{`;
						code += methods.map(field => {
							return `
		.${field.name}=${wclapClass}::nativeProxy_${field.name}<realtime>`;
						}).join(',');
						code += `
	};
	return &proxy;
}`;
					} else {
						code += `

template<>
void wasmToNative<const ${name}>(ScopedThread &scoped, WasmP wasmP, const ${name} *&nativeP);

inline void generated_wasmToNative(ScopedThread &scoped, WasmP wasmP, const ${name} *&constNativeP) {
	auto wasm = scoped.view<${wclapClass}>(wasmP);
	auto *native = scoped.arenas.nativeTyped<${name}>();
	constNativeP = native;`;
						structFields.forEach(field => {
							let fieldType = getType(field.type);
							if (fieldType.compatible) {
								if (field.arrayCount) {
									code += `
	for (size_t i = 0; i < ${field.arrayCount}; ++i) {
		native->${field.name}[i] = wasm.${field.name}(i);
	}`;
								} else {
									code += `
	native->${field.name} = wasm.${field.name}();`;
								}
							} else if (field.argTypes) {
								code += `
	native->${field.name} = ${wclapClass}::nativeProxy_${field.name}<false>;`;
							} else {
								if (field.arrayCount) {
									code += `
	for (size_t i = 0; i < ${field.arrayCount}; ++i) {
		wasmToNative(scoped, wasm.${field.name}(i), native->${field.name}[i]);
	}`;
								} else {
									code += `
	wasmToNative(scoped, wasm.${field.name}(), native->${field.name});`;
								}
							}
						});
						code += `
}`;
					}
				}

				if (!isWasmOnly && !noTranslation) {
					code += `

template<>
void nativeToWasm<const ${name}>(ScopedThread &scoped, const ${name} *native, WasmP &wasmP);`;
				}
				code += `

template<>
void * & nativeProxyContextPointer<${name}>(const ${name} *native);`;
			}
		});
	}

	addDirect("uint8_t", 1);
	addDirect("uint16_t", 2);
	addDirect("uint32_t", 4);
	addDirect("uint64_t", 8);
	addDirect("int8_t", 1);
	addDirect("int16_t", 2);
	addDirect("int32_t", 4);
	addDirect("int64_t", 8);
	addDirect("float", 4);
	addDirect("double", 8);
	addDirect("bool", 1);
	addDirect("char", 1); // means it gets copied directly if it's part of the class

	addFile("version.h");
	addFile("host.h");
	addFile("fixedpoint.h");
	addFile("id.h");
	
	addFile("events.h");
	addFile("audio-buffer.h");
	addFile("process.h");
	addFile("plugin-features.h");
	addFile("plugin.h");
	addFile("factory/plugin-factory.h");
	addFile("timestamp.h");
	addFile("universal-plugin-id.h");
	addFile("factory/preset-discovery.h");
	addFile("entry.h");

	addFile("string-sizes.h");
	addFile("color.h");
	addFile("stream.h");

	addFile("ext/ambisonic.h");
	addFile("ext/audio-ports.h");
	addFile("ext/audio-ports-activation.h");
	addFile("ext/audio-ports-config.h");
	addFile("ext/configurable-audio-ports.h");
	addFile("ext/context-menu.h");
	addFile("ext/event-registry.h");
	doNotTranslate("clap_window");
	addFile("ext/gui.h");
	addFile("ext/latency.h");
	addFile("ext/log.h");
	addFile("ext/note-name.h");
	addFile("ext/note-ports.h");
	addFile("ext/param-indication.h");
//	addCustom("clap_param_info", "cookie");
	addFile("ext/params.h");
	doNotTranslate("clap_plugin_posix_fd_support");
	doNotTranslate("clap_host_posix_fd_support");
	addFile("ext/posix-fd-support.h");
	addFile("ext/preset-load.h");
	addFile("ext/remote-controls.h");
	addFile("ext/render.h");
	addFile("ext/state-context.h");
	addFile("ext/state.h");
	addFile("ext/surround.h");
	addFile("ext/tail.h");
	addFile("ext/thread-check.h");
	addFile("ext/thread-pool.h");
	addFile("ext/timer-support.h");
	addFile("ext/track-info.h");
	addFile("ext/voice-info.h");

	// Skip most drafts, but this one is extremely useful for WCLAP
	addFile("ext/draft/webview.h");

	code += `
	
}} // namespace
`;
	fs.writeFileSync(__dirname + `/source/wclap${bits}/translate-clap-structs.generated.h`, code);
}

translate(false);
translate(true);

fs.writeFileSync(__dirname + '/source/class-id.generated.h', `#pragma once

namespace wclap {

enum class ClassId {
	${Object.keys(classIdEnum).sort().join(',\n\t')}
};

template<class ClapStruct>
inline ClassId getClassId();

${Object.keys(classIdEnum).sort().map(name => {
	return 'template<>\ninline constexpr ClassId getClassId<' + name + '>() {\n\treturn ClassId::' + name + ';\n}';
}).join('\n\n')}

}
`);
